<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ’çƒæŠ€è¡“çµ±è¨ˆå¹³å°</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 12px 24px;
            background: rgba(49, 86, 116, 0.9);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            color: #fff;
        }

        .tab-btn.active {
            background: rgb(0, 0, 0);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transform: translateY(-2px);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 15px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        .action-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .btn-success { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }
        .btn-danger  { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); }
        .btn-warning { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .btn-info    { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        th, td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #eee;
            align-items: center;
        }

        .stat-label {
            font-weight: bold;
            color: #555;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #667eea;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin: 20px 0;
        }

        .mvp-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            font-size: 1.5em;
            margin: 20px 0;
        }

        .skill-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .skill-btn {
            padding: 15px;
            font-size: 14px;
        }

        .match-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .match-item {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .delete-btn {
            background: #e74c3c;
            padding: 5px 10px;
            font-size: 12px;
        }

        @media (max-width: 768px) {
            .form-grid, .action-grid {
                grid-template-columns: 1fr;
            }
            .chart-container {
                height: 300px;
            }
            .skill-buttons {
                grid-template-columns: 1fr;
            }
        }

        /* æ­·å²çµ±è¨ˆå½ˆå‡ºè¦–çª— */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-card {
            background: #fff;
            border-radius: 12px;
            max-width: 900px;
            width: 95%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .modal-close {
            text-align: right;
            margin-bottom: 10px;
        }

        .modal-close button {
            background: #e74c3c;
            border-radius: 20px;
            padding: 6px 12px;
            font-size: 12px;
        }

        /* å°æç¤ºæ–‡å­— */
        .feedback {
            margin-top: 10px;
            color: #333;
            font-weight: bold;
        }

        .feedback small {
            font-weight: normal;
            color: #777;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>ğŸ æ’çƒæŠ€è¡“çµ±è¨ˆå¹³å°</h1>

    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab(event, 'match')">æ¯”è³½è¨­å®š</button>
        <button class="tab-btn" onclick="switchTab(event, 'record')">æŠ€è¡“è¨˜éŒ„</button>
        <button class="tab-btn" onclick="switchTab(event, 'stats')">æ•¸æ“šçµ±è¨ˆ</button>
        <button class="tab-btn" onclick="switchTab(event, 'analysis')">æ•¸æ“šåˆ†æ</button>
        <button class="tab-btn" onclick="switchTab(event, 'history')">æ­·å²ç´€éŒ„</button>
    </div>

    <!-- æ¯”è³½è¨­å®š -->
    <div id="tab-match" class="tab-content active">
        <div class="card">
            <h2>æ¯”è³½è³‡è¨Šè¨­å®š</h2>
            <div class="form-grid">
                <div class="input-group">
                    <label>æ¯”è³½æ—¥æœŸ</label>
                    <input type="date" id="matchDate">
                </div>
                <div class="input-group">
                    <label>æ¯”è³½åœ°é»</label>
                    <input type="text" id="matchLocation" placeholder="è¼¸å…¥æ¯”è³½åœ°é»">
                </div>
                <div class="input-group">
                    <label>å°æ‰‹éšŠä¼</label>
                    <input type="text" id="opponentTeam" placeholder="è¼¸å…¥å°æ‰‹éšŠå">
                </div>
                <div class="input-group">
                    <label>ç•¶å‰å±€æ•¸</label>
                    <select id="currentSet">
                        <option value="1">ç¬¬ä¸€å±€</option>
                        <option value="2">ç¬¬äºŒå±€</option>
                        <option value="3">ç¬¬ä¸‰å±€</option>
                        <option value="4">ç¬¬å››å±€</option>
                        <option value="5">ç¬¬äº”å±€</option>
                    </select>
                </div>
            </div>
            <div class="action-grid">
                <button class="btn-primary" onclick="startMatch()">é–‹å§‹æ–°æ¯”è³½</button>
                <button class="btn-warning" onclick="finishMatch()">çµæŸæœ¬å ´æ¯”è³½ä¸¦å­˜å…¥æ­·å²</button>
            </div>
            <!-- æ¯”è³½ç‹€æ…‹æç¤º -->
            <div id="matchFeedback" class="feedback"></div>
        </div>

        <div class="card">
            <h2>çƒå“¡ç®¡ç†</h2>
            <div class="input-group">
                <label>æ–°å¢çƒå“¡</label>
                <input type="text" id="playerName" placeholder="è¼¸å…¥çƒå“¡å§“åæˆ–èƒŒè™Ÿ">
            </div>
            <button class="btn-success" onclick="addPlayer()">â• æ–°å¢çƒå“¡</button>
            
            <table>
                <thead>
                <tr>
                    <th>çƒå“¡</th>
                    <th>æ“ä½œ</th>
                </tr>
                </thead>
                <tbody id="playerListTable"></tbody>
            </table>
        </div>
    </div>

    <!-- æŠ€è¡“è¨˜éŒ„ -->
    <div id="tab-record" class="tab-content">
        <!-- ç›®å‰æ¯”è³½è³‡è¨Šé¡¯ç¤º -->
        <div class="card">
            <h2>ç›®å‰æ¯”è³½è³‡è¨Š</h2>
            <div id="currentMatchInfo"></div>
        </div>

        <div class="card">
            <h2>é¸æ“‡çƒå“¡</h2>
            <select id="recordPlayerSelect">
                <option value="">-- è«‹é¸æ“‡çƒå“¡ --</option>
            </select>
            <p class="feedback">
                å°æç¤ºï¼šå¦‚æœè¦è¨˜éŒ„ç¬¬ 2 å±€ä»¥ä¸Šï¼Œè«‹å…ˆåœ¨ã€Œæ¯”è³½è¨­å®šã€é é¢æ›´æ”¹ã€Œç•¶å‰å±€æ•¸ã€ï¼Œå†å›åˆ°é€™è£¡è¨˜éŒ„ã€‚
            </p>
        </div>

        <div class="card">
            <h2>æŠ€è¡“å‹•ä½œè¨˜éŒ„</h2>
            <div class="skill-buttons">
                <button class="btn-success skill-btn" onclick="recordAction('serve', 'score')">ğŸ¾ ç™¼çƒå¾—åˆ†</button>
                <button class="btn-danger skill-btn" onclick="recordAction('serve', 'error')">ğŸ¾ ç™¼çƒå¤±èª¤</button>
                
                <button class="btn-success skill-btn" onclick="recordAction('receive', 'score')">ğŸ“¥ æ¥ç™¼å¾—åˆ†</button>
                <button class="btn-danger skill-btn" onclick="recordAction('receive', 'error')">ğŸ“¥ æ¥ç™¼å¤±èª¤</button>
                
                <button class="btn-success skill-btn" onclick="recordAction('attack', 'score')">âš¡ æ”»æ“ŠæˆåŠŸ</button>
                <button class="btn-danger skill-btn" onclick="recordAction('attack', 'error')">âš¡ æ”»æ“Šå¤±èª¤</button>
                
                <button class="btn-success skill-btn" onclick="recordAction('block', 'score')">ğŸ›¡ï¸ æ””ç¶²å¾—åˆ†</button>
                <button class="btn-danger skill-btn" onclick="recordAction('block', 'error')">ğŸ›¡ï¸ æ””ç¶²å¤±èª¤</button>
                
                <button class="btn-success skill-btn" onclick="recordAction('set', 'score')">ğŸ¤² èˆ‰çƒå¾—åˆ†</button>
                <button class="btn-danger skill-btn" onclick="recordAction('set', 'error')">ğŸ¤² èˆ‰çƒå¤±èª¤</button>
                
                <button class="btn-success skill-btn" onclick="recordAction('defense', 'score')">ğŸ›Ÿ é˜²å®ˆæˆåŠŸ</button>
                <button class="btn-danger skill-btn" onclick="recordAction('defense', 'error')">ğŸ›Ÿ é˜²å®ˆå¤±èª¤</button>
            </div>

            <!-- æ’¤éŠ·ä¸Šä¸€ç­† -->
            <div style="margin-top:15px;">
                <button class="btn-info" onclick="undoLastAction()">â†©ï¸ æ’¤éŠ·æœ¬å±€æœ€å¾Œä¸€ç­†ç´€éŒ„</button>
            </div>

            <!-- æŠ€è¡“å‹•ä½œæç¤º -->
            <div id="actionFeedback" class="feedback"></div>
        </div>
    </div>

    <!-- æ•¸æ“šçµ±è¨ˆ -->
    <div id="tab-stats" class="tab-content">
        <div class="card">
            <h2>çƒå“¡æŠ€è¡“çµ±è¨ˆ</h2>

            <!-- å±€æ•¸ç¯©é¸ -->
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:10px;">
                <label for="statsSetSelect" style="font-weight:bold;">é¡¯ç¤ºå±€æ•¸ï¼š</label>
                <select id="statsSetSelect" onchange="onSetFilterChange()">
                    <option value="all">å…¨éƒ¨å±€æ•¸</option>
                </select>
                <span><small>æ›´æ”¹é€™è£¡å¯ä»¥åˆ‡æ›åŒä¸€å ´æ¯”è³½ä¸åŒå±€æ•¸çš„çµ±è¨ˆ</small></span>
            </div>

            <div style="overflow-x: auto;">
                <table id="statsTable">
                    <thead>
                    <tr>
                        <th>çƒå“¡</th>
                        <th>ç™¼çƒ</th>
                        <th>æ¥ç™¼</th>
                        <th>æ”»æ“Š</th>
                        <th>æ””ç¶²</th>
                        <th>èˆ‰çƒ</th>
                        <th>é˜²å®ˆ</th>
                        <th>ç¸½å¾—åˆ†</th>
                        <th>ç¸½å¤±èª¤</th>
                    </tr>
                    </thead>
                    <tbody id="statsTableBody"></tbody>
                </table>
            </div>
        </div>

        <div class="card">
            <h2>æˆåŠŸç‡çµ±è¨ˆ</h2>
            <div id="successRateStats"></div>
        </div>

        <!-- æœ¬å±€äº‹ä»¶ç´€éŒ„ -->
        <div class="card">
            <h2>æœ¬å±€äº‹ä»¶ç´€éŒ„</h2>
            <div id="setEventLog" class="match-list"></div>
        </div>
    </div>

    <!-- æ•¸æ“šåˆ†æ -->
    <div id="tab-analysis" class="tab-content">
        <div class="card">
            <h2>åˆ†æè¨­å®š</h2>
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                <label style="font-weight:bold;">ç›®å‰åˆ†æå±€æ•¸ï¼š</label>
                <span id="analysisSetDisplay">å…¨éƒ¨å±€æ•¸</span>
            </div>
        </div>

        <div id="mvpDisplay"></div>

        <div class="card">
            <h2>å„é …æŠ€è¡“æ’å</h2>
            <div id="rankingDisplay"></div>
        </div>

        <div class="card">
            <h2>æŠ€è¡“çµ±è¨ˆåœ–è¡¨</h2>
            <div class="chart-container">
                <canvas id="skillChart"></canvas>
            </div>
        </div>

        <div class="card">
            <h2>æˆåŠŸç‡åœ–è¡¨</h2>
            <div class="chart-container">
                <canvas id="rateChart"></canvas>
            </div>
        </div>
    </div>

    <!-- æ­·å²ç´€éŒ„ -->
    <div id="tab-history" class="tab-content">
        <div class="card">
            <h2>æ¯”è³½æ­·å²</h2>
            <div class="action-grid">
                <button class="btn-danger" onclick="clearHistory()">æ¸…é™¤æ‰€æœ‰æ­·å²</button>
            </div>
            <div class="match-list" id="matchHistory"></div>
        </div>
    </div>
</div>

<!-- æ­·å²çµ±è¨ˆå½ˆå‡ºè¦–çª— -->
<div id="historyModal" class="modal-overlay" onclick="onHistoryModalBackgroundClick(event)">
    <div class="modal-card">
        <div class="modal-close">
            <button onclick="closeHistoryModal()">é—œé–‰</button>
        </div>
        <div id="historyModalContent"></div>
    </div>
</div>

<!-- çµæŸæ¯”è³½ï¼šè¼¸å…¥å„å±€æ¯”åˆ†çš„å½ˆå‡ºè¦–çª— -->
<div id="finishMatchModal" class="modal-overlay" onclick="onFinishModalBackgroundClick(event)">
    <div class="modal-card">
        <div class="modal-close">
            <button onclick="closeFinishMatchModal()">é—œé–‰</button>
        </div>
        <h2 style="color:#667eea; margin-bottom:10px;">è¼¸å…¥å„å±€æœ€çµ‚æ¯”åˆ†</h2>
        <p style="margin-bottom:10px;">è«‹å¡«å¯«æœ¬å ´æ¯”è³½å„å±€çš„ã€Œæˆ‘æ–¹å¾—åˆ†ã€èˆ‡ã€Œå°æ‰‹å¾—åˆ†ã€ï¼Œå†æŒ‰ã€Œç¢ºèªå„²å­˜ä¸¦çµæŸæ¯”è³½ã€ã€‚</p>
        <div id="finishMatchSetsContainer"></div>

        <div style="margin-top:15px; text-align:right;">
            <button class="btn-warning" style="margin-right:8px;" onclick="closeFinishMatchModal()">å–æ¶ˆ</button>
            <button class="btn-primary" onclick="confirmFinishMatch()">âœ… ç¢ºèªå„²å­˜ä¸¦çµæŸæ¯”è³½</button>
        </div>
    </div>
</div>


<script>
    // ===== ç‹€æ…‹è®Šæ•¸ =====
    let currentMatch = null;     // ç›®å‰é€²è¡Œä¸­çš„æ¯”è³½
    let players = [];            // ç›®å‰æ¯”è³½çš„çƒå“¡æ¸…å–®ï¼ˆé™£åˆ—ï¼‰
    let matchHistory = [];       // æ­·å²æ¯”è³½
    let currentViewSet = 'all';  // stats / analysis ç›®å‰é¡¯ç¤ºçš„å±€æ•¸

    // æ­·å²è¦–çª—ç”¨
    let currentHistoryIdx = null;
    let currentHistoryViewSet = 'all';

    // æŠ€è¡“èˆ‡çµæœå°ç…§
    const SKILL_LABELS = {
        serve: 'ç™¼çƒ',
        receive: 'æ¥ç™¼',
        attack: 'æ”»æ“Š',
        block: 'æ””ç¶²',
        set: 'èˆ‰çƒ',
        defense: 'é˜²å®ˆ'
    };
    const RESULT_LABELS = {
        score: 'æˆåŠŸ',
        error: 'å¤±èª¤'
    };

    // ===== è¼‰å…¥ / å„²å­˜ =====
    function loadData() {
    const saved = localStorage.getItem('volleyballStatsV2');
    if (saved) {
        try {
            const data = JSON.parse(saved);
            currentMatch   = data.currentMatch || null;
            players        = data.players || [];
            // âŒ ä¸å†å¾ localStorage æ‹¿æ­·å²è³‡æ–™
            // matchHistory   = data.matchHistory || [];
            currentViewSet = data.currentViewSet || 'all';
        } catch (e) {
            console.error('è®€å– localStorage å¤±æ•—ï¼Œæ¸…é™¤èˆŠè³‡æ–™', e);
            localStorage.removeItem('volleyballStatsV2');
        }
    }
}


    function saveData() {
    const data = {
        currentMatch,
        players,
        // âŒ ä¸æŠŠæ­·å²ç´€éŒ„å­˜åˆ° localStorage
        // matchHistory,
        currentViewSet
    };
    localStorage.setItem('volleyballStatsV2', JSON.stringify(data));
}


    window.onload = function() {
        loadData();  // ä¿ç•™èˆŠçš„æœ¬æ©Ÿè³‡æ–™ï¼ˆé›¢ç·šç”¨ï¼‰
        const dateInput = document.getElementById('matchDate');
        if (dateInput) {
            dateInput.valueAsDate = new Date();
        }

        updateAllDisplays();
        updateSetFilterOptions();
        updateSetEventLog();
        updateAnalysis();
        updateCurrentMatchInfo();

        const setSelect = document.getElementById('currentSet');
        if (setSelect) {
            setSelect.addEventListener('change', () => {
                updateCurrentMatchInfo();
                showMatchFeedback(`ç›®å‰è¨˜éŒ„å±€æ•¸å·²æ”¹ç‚ºï¼šç¬¬ ${setSelect.value} å±€`);
            });
        }

        // ä¸€è¼‰å…¥é é¢å°±å» Supabase æŠ“æœ€æ–°çš„æ­·å²æ¯”è³½
        loadMatchHistoryFromSupabase();
    };

    // ===== å°æç¤ºå‡½å¼ =====
    function showMatchFeedback(msg) {
        const box = document.getElementById('matchFeedback');
        if (!box) return;
        box.innerHTML = msg;
        setTimeout(() => {
            if (box.innerHTML === msg) {
                box.innerHTML = '';
            }
        }, 4000);
    }

    function showActionFeedback(msg) {
        const box = document.getElementById('actionFeedback');
        if (!box) return;
        box.innerHTML = msg;
        setTimeout(() => {
            if (box.innerHTML === msg) {
                box.innerHTML = '';
            }
        }, 4000);
    }

    // ===== å…±ç”¨ UI =====
    function switchTab(e, tabName) {
        document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`tab-${tabName}`).classList.add('active');
        if (e && e.target) e.target.classList.add('active');

        if (tabName === 'stats') {
            updateStatsTable();
        } else if (tabName === 'analysis') {
            updateAnalysis();
        } else if (tabName === 'history') {
            displayMatchHistory();
        }
    }

    function createEmptyStats() {
        return {
            serve:   { score: 0, error: 0 },
            receive: { score: 0, error: 0 },
            attack:  { score: 0, error: 0 },
            block:   { score: 0, error: 0 },
            set:     { score: 0, error: 0 },
            defense: { score: 0, error: 0 }
        };
    }

    // æ ¹æ“š currentMatch çš„ events + players è¨ˆç®—æŸä¸€å±€ï¼ˆæˆ–å…¨éƒ¨ï¼‰çµ±è¨ˆ
    function computeStats(viewSet = 'all') {
        const stats = {};
        // å…ˆæŠŠæ‰€æœ‰çƒå“¡å»ºå¥½ 0
        players.forEach(name => {
            stats[name] = createEmptyStats();
        });

        if (!currentMatch || !currentMatch.sets) return stats;

        const setKeys = viewSet === 'all'
            ? Object.keys(currentMatch.sets || {})
            : [viewSet];

        setKeys.forEach(setKey => {
            const events = currentMatch.sets[setKey] || [];
            events.forEach(ev => {
                const { player, skill, result } = ev;
                if (!stats[player]) {
                    stats[player] = createEmptyStats();
                }
                if (stats[player][skill]) {
                    stats[player][skill][result]++;
                }
            });
        });

        return stats;
    }

    // çµ¦æ­·å²æ¯”è³½ç”¨çš„ stats è¨ˆç®—
    function computeStatsForMatch(match, viewSet = 'all') {
        const stats = {};
        if (!match || !match.sets) return stats;

        const setKeys = viewSet === 'all'
            ? Object.keys(match.sets || {})
            : [viewSet];

        setKeys.forEach(setKey => {
            const events = match.sets[setKey] || [];
            events.forEach(ev => {
                const { player, skill, result } = ev;
                if (!stats[player]) {
                    stats[player] = createEmptyStats();
                }
                if (stats[player][skill]) {
                    stats[player][skill][result]++;
                }
            });
        });

        return stats;
    }

    // ===== æ¯”è³½æ§åˆ¶ =====
    function startMatch() {
        const date = document.getElementById('matchDate').value;
        const location = document.getElementById('matchLocation').value.trim();
        const opponent = document.getElementById('opponentTeam').value.trim();

        if (!date || !location || !opponent) {
            alert('è«‹å¡«å¯«å®Œæ•´çš„æ¯”è³½è³‡è¨Šï¼');
            showMatchFeedback('âš ï¸ å°šæœªå¡«å¯«å®Œæ•´æ¯”è³½è³‡è¨Šï¼Œç„¡æ³•é–‹å§‹æ¯”è³½ã€‚');
            return;
        }

        // è‹¥å·²æœ‰é€²è¡Œä¸­çš„æ¯”è³½
        if (currentMatch) {
    const hasEvents = currentMatch.sets &&
        Object.values(currentMatch.sets).some(arr => arr && arr.length > 0);

    if (hasEvents) {
        const ok = confirm('ç›®å‰æœ‰ä¸€å ´å°šæœªçµæŸçš„æ¯”è³½ï¼Œé–‹å§‹æ–°æ¯”è³½å‰è¦å…ˆæŠŠèˆŠæ¯”è³½å­˜å…¥æ­·å²ç´€éŒ„å—ï¼Ÿ');
        if (ok) {
            const snapshot = JSON.parse(JSON.stringify(currentMatch));
            snapshot.players = [...players];

            // æ”¾é€²å‰ç«¯çš„æ­·å²é™£åˆ—ï¼ˆæ–¹ä¾¿ç•«é¢ç«‹åˆ»æ›´æ–°ï¼‰
            matchHistory.unshift(snapshot);
            displayMatchHistory();

            // ä¸Ÿåˆ° Supabaseï¼ˆä¸ç”¨ awaitï¼Œå¤±æ•—æ™‚åœ¨å‡½å¼è£¡æœƒ console.errorï¼‰
            saveMatchToSupabase(snapshot);
        } else {
            showMatchFeedback('å·²å–æ¶ˆé–‹å§‹æ–°æ¯”è³½ã€‚');
            return;
        }
    }
}

        // é–‹æ–°æ¯”è³½ï¼ˆæ¸…ç©ºçƒå“¡èˆ‡å±€æ•¸ï¼‰
        currentMatch = {
            id: Date.now(),
            date,
            location,
            opponent,
            startTime: new Date().toISOString(),
            sets: {},        // å„å±€äº‹ä»¶
            setScores: {},   // ä¹‹å¾Œæœƒæ”¾å„å±€æ¯”åˆ†
            finalSets: null  // ä¹‹å¾Œæœƒæ”¾æ•´å ´ã€Œå¹¾æ¯”å¹¾ã€
        };
        players = [];
        currentViewSet = 'all';

        saveData();
        updateAllDisplays();
        updateSetFilterOptions();
        updateSetEventLog();
        updateAnalysis();
        updateCurrentMatchInfo();

        alert(`âœ… å·²æ–°å¢ä¸€å ´æ¯”è³½ï¼\n\næ—¥æœŸï¼š${date}\nåœ°é»ï¼š${location}\nå°æ‰‹ï¼š${opponent}\n\nè«‹åˆ‡æ›åˆ°ã€ŒæŠ€è¡“è¨˜éŒ„ã€é é¢é–‹å§‹è¨˜éŒ„ã€‚`);
        showMatchFeedback(`âœ… å·²é–‹å§‹æ–°æ¯”è³½ï¼š${date} @ ${location} å°æˆ° ${opponent}`);
    }

    // é»ã€ŒçµæŸæœ¬å ´æ¯”è³½ä¸¦å­˜å…¥æ­·å²ã€æ™‚å…ˆè·³å‡ºè¼¸å…¥æ¯”åˆ†è¦–çª—
    function finishMatch() {
        if (!currentMatch) {
            alert('ç›®å‰æ²’æœ‰é€²è¡Œä¸­çš„æ¯”è³½ã€‚');
            showMatchFeedback('âš ï¸ æ²’æœ‰é€²è¡Œä¸­çš„æ¯”è³½å¯ä»¥çµæŸã€‚');
            return;
        }
        openFinishMatchModal();
    }

    // å»ºç«‹å„å±€æ¯”åˆ†è¼¸å…¥æ¬„ä½ä¸¦æ‰“é–‹ modal
    function openFinishMatchModal() {
        const modal = document.getElementById('finishMatchModal');
        const container = document.getElementById('finishMatchSetsContainer');
        if (!modal || !container) return;

        container.innerHTML = '';

        // å·²æœ‰ç´€éŒ„çš„å±€æ•¸
        const existingSetKeys = currentMatch.sets
            ? Object.keys(currentMatch.sets).map(k => parseInt(k, 10)).filter(n => !isNaN(n))
            : [];

        const setSelect = document.getElementById('currentSet');
        const currentSetVal = setSelect ? parseInt(setSelect.value || '1', 10) : 1;

        let maxSet = existingSetKeys.length ? Math.max(...existingSetKeys) : 1;
        if (currentSetVal > maxSet) maxSet = currentSetVal;
        if (!maxSet || maxSet < 1) maxSet = 1;

        const setScores = currentMatch.setScores || {};

        for (let i = 1; i <= maxSet; i++) {
            const old = setScores[i] || {};
            const ourVal  = (old.our  != null) ? old.our  : '';
            const oppVal  = (old.opp  != null) ? old.opp  : '';

            const row = document.createElement('div');
            row.style.marginBottom = '10px';
            row.innerHTML = `
                <div style="display:flex; flex-wrap:wrap; gap:8px; align-items:center;">
                    <strong style="min-width:70px;">ç¬¬ ${i} å±€</strong>
                    <label>æˆ‘æ–¹å¾—åˆ†ï¼š
                        <input type="number" id="finishSet-${i}-our" min="0" style="width:80px; padding:4px 6px;" value="${ourVal}">
                    </label>
                    <label>å°æ‰‹å¾—åˆ†ï¼š
                        <input type="number" id="finishSet-${i}-opp" min="0" style="width:80px; padding:4px 6px;" value="${oppVal}">
                    </label>
                    <small style="color:#999;">ï¼ˆå¯ç•™ç™½è¡¨ç¤ºè©²å±€æœªé€²è¡Œï¼‰</small>
                </div>
            `;
            container.appendChild(row);
        }

        modal.style.display = 'flex';
    }

    // é» modal è£¡ã€Œç¢ºèªå„²å­˜ä¸¦çµæŸæ¯”è³½ã€
    async function confirmFinishMatch() {
        if (!currentMatch) {
            closeFinishMatchModal();
            return;
        }

        const setScores = {};
        let ourWins = 0;
        let oppWins = 0;

        const existingSetKeys = currentMatch.sets
            ? Object.keys(currentMatch.sets).map(k => parseInt(k, 10)).filter(n => !isNaN(n))
            : [];

        const setSelect = document.getElementById('currentSet');
        const currentSetVal = setSelect ? parseInt(setSelect.value || '1', 10) : 1;

        let maxSet = existingSetKeys.length ? Math.max(...existingSetKeys) : 1;
        if (currentSetVal > maxSet) maxSet = currentSetVal;
        if (!maxSet || maxSet < 1) maxSet = 1;

        // é€å±€è®€å–è¼¸å…¥å€¼
        for (let i = 1; i <= maxSet; i++) {
            const ourInput = document.getElementById(`finishSet-${i}-our`);
            const oppInput = document.getElementById(`finishSet-${i}-opp`);
            if (!ourInput || !oppInput) continue;

            const ourRaw = ourInput.value.trim();
            const oppRaw = oppInput.value.trim();

            // å…©å€‹éƒ½ç©º â†’ è¦–ç‚ºè©²å±€æ²’æ‰“
            if (ourRaw === '' && oppRaw === '') {
                continue;
            }

            // åªå¡«ä¸€é‚Š â†’ è¦–ç‚ºéŒ¯èª¤
            if (ourRaw === '' || oppRaw === '') {
                alert(`ç¬¬ ${i} å±€çš„æ¯”åˆ†è«‹ã€Œå…©é‚Šéƒ½å¡«ã€ï¼Œæˆ–ã€Œå…©é‚Šéƒ½ç•™ç™½ã€ã€‚`);
                return;
            }

            const our = parseInt(ourRaw, 10);
            const opp = parseInt(oppRaw, 10);

            if (isNaN(our) || isNaN(opp) || our < 0 || opp < 0) {
                alert(`ç¬¬ ${i} å±€çš„æ¯”åˆ†å¿…é ˆæ˜¯å¤§æ–¼ç­‰æ–¼ 0 çš„æ•´æ•¸ã€‚`);
                return;
            }

            setScores[i] = { our, opp };
            if (our > opp) ourWins++;
            else if (opp > our) oppWins++;
        }

        // æŠŠæ¯”åˆ†å¯«å› currentMatch
        currentMatch.setScores = setScores;
        currentMatch.finalSets = { our: ourWins, opp: oppWins };

        // å‘¼å«çœŸæ­£çš„ã€ŒçµæŸæ¯”è³½ + å­˜æª”ã€æµç¨‹
        await reallyFinishMatch();

        closeFinishMatchModal();
    }

    // çœŸæ­£çµæŸæ¯”è³½ä¸¦è™•ç†æ”¶å°¾
    async function reallyFinishMatch() {
        if (!currentMatch) return;

        // è£œä¸ŠçµæŸæ™‚é–“ & çƒå“¡åå–®
        currentMatch.endTime = new Date().toISOString();
        currentMatch.players = Array.isArray(players) ? [...players] : [];

        // åšä¸€ä»½ä¹¾æ·¨å¿«ç…§ï¼Œé¿å…ä¹‹å¾Œè¢«ä¿®æ”¹
        const snapshot = JSON.parse(JSON.stringify(currentMatch));

        // æ”¾é€²æœ¬æ©Ÿæ­·å²ç´€éŒ„ï¼ˆæœ€æ–°ä¸€å ´æ”¾æœ€ä¸Šé¢ï¼‰
        matchHistory.unshift(snapshot);

        // å„²å­˜åˆ° localStorage
        saveData();

        // æ›´æ–°æ­·å²åˆ—è¡¨ç•«é¢
        displayMatchHistory();

        // åŒæ­¥åˆ° Supabaseï¼ˆé›²ç«¯ï¼‰
        await saveMatchToSupabase(snapshot);

        // é¡¯ç¤ºå°æé†’ï¼ˆå¦‚æœæœ‰è¼¸å…¥ finalSets å°±é¡¯ç¤ºå¹¾æ¯”å¹¾ï¼‰
        let finalText = '';
        if (snapshot.finalSets && snapshot.finalSets.our != null && snapshot.finalSets.opp != null) {
            finalText = ` æœ€çµ‚å±€æ•¸ï¼š${snapshot.finalSets.our} æ¯” ${snapshot.finalSets.opp}`;
        }
        showMatchFeedback(`âœ… æœ¬å ´æ¯”è³½å·²çµæŸä¸¦å­˜å…¥æ­·å²ï¼${finalText}`);

        // æ¸…ç©ºç›®å‰æ¯”è³½èˆ‡çƒå“¡ï¼Œå›åˆ°åˆå§‹ç‹€æ…‹
        currentMatch = null;
        players = [];
        currentViewSet = 'all';

        updateAllDisplays();
        updateSetFilterOptions();
        updateSetEventLog();
        updateAnalysis();
        updateCurrentMatchInfo();
        saveData();
    }

    function closeFinishMatchModal() {
        const modal = document.getElementById('finishMatchModal');
        if (modal) modal.style.display = 'none';
    }

    function onFinishModalBackgroundClick(e) {
        if (e.target && e.target.id === 'finishMatchModal') {
            closeFinishMatchModal();
        }
    }

    // ===== çƒå“¡ç®¡ç† =====
    function addPlayer() {
        const input = document.getElementById('playerName');
        const name = input.value.trim();
        if (!name) {
            alert('è«‹è¼¸å…¥çƒå“¡å§“åæˆ–èƒŒè™Ÿï¼');
            return;
        }
        if (players.includes(name)) {
            alert('æ­¤çƒå“¡å·²å­˜åœ¨ï¼');
            return;
        }
        players.push(name);
        input.value = '';
        saveData();
        updateAllDisplays();
        alert(`çƒå“¡ã€Œ${name}ã€æ–°å¢æˆåŠŸï¼`);
    }

    function deletePlayer(name) {
        if (!confirm(`ç¢ºå®šè¦åˆªé™¤çƒå“¡ã€Œ${name}ã€å—ï¼Ÿ`)) return;
        players = players.filter(p => p !== name);

        // åˆªé™¤ç¾æœ‰å±€æ•¸ä¸­çš„è©²çƒå“¡äº‹ä»¶
        if (currentMatch && currentMatch.sets) {
            Object.keys(currentMatch.sets).forEach(setKey => {
                currentMatch.sets[setKey] =
                    (currentMatch.sets[setKey] || []).filter(ev => ev.player !== name);
            });
        }

        saveData();
        updateAllDisplays();
        updateSetEventLog();
        updateAnalysis();
    }

    // ===== è¨˜éŒ„å‹•ä½œ & æ’¤éŠ· =====
    function recordAction(skill, result) {
        const playerName = document.getElementById('recordPlayerSelect').value;
        const setSelect = document.getElementById('currentSet');
        const currentSet = setSelect ? (setSelect.value || '1') : '1';

        if (!playerName) {
            alert('è«‹å…ˆé¸æ“‡çƒå“¡ï¼');
            showActionFeedback('âš ï¸ å°šæœªé¸æ“‡çƒå“¡ï¼Œç„¡æ³•è¨˜éŒ„æŠ€è¡“å‹•ä½œã€‚');
            return;
        }

        if (!currentMatch) {
            alert('è«‹å…ˆåœ¨ã€Œæ¯”è³½è¨­å®šã€é é¢é–‹å§‹æ–°æ¯”è³½ï¼');
            showActionFeedback('âš ï¸ å°šæœªé–‹å§‹æ¯”è³½ï¼Œè«‹å…ˆåˆ°ã€Œæ¯”è³½è¨­å®šã€é–‹å§‹æ¯”è³½ã€‚');
            return;
        }

        if (!players.includes(playerName)) {
            players.push(playerName);
        }

        if (!currentMatch.sets[currentSet]) {
            currentMatch.sets[currentSet] = [];
        }

        const event = {
            player: playerName,
            skill,
            result,
            time: new Date().toISOString()
        };

        currentMatch.sets[currentSet].push(event);

        saveData();
        updateAllDisplays();
        updateSetFilterOptions();
        updateSetEventLog();
        updateAnalysis();

        const skillText  = SKILL_LABELS[skill]  || skill;
        const resultText = RESULT_LABELS[result] || result;
        showActionFeedback(`âœ… å·²è¨˜éŒ„ï¼šç¬¬ ${currentSet} å±€ã€€${playerName}ã€€${skillText}ï¼ˆ${resultText}ï¼‰`);
    }

    function undoLastAction() {
        if (!currentMatch || !currentMatch.sets) {
            alert('ç›®å‰æ²’æœ‰å¯ä»¥æ’¤éŠ·çš„æ¯”è³½ç´€éŒ„ã€‚');
            showActionFeedback('âš ï¸ ç›®å‰æ²’æœ‰å¯ä»¥æ’¤éŠ·çš„ç´€éŒ„ã€‚');
            return;
        }
        const setSelect = document.getElementById('currentSet');
        const currentSet = setSelect ? (setSelect.value || '1') : '1';

        const events = currentMatch.sets[currentSet] || [];
        if (!events.length) {
            alert(`ç¬¬ ${currentSet} å±€ç›®å‰å°šç„¡ç´€éŒ„å¯æ’¤éŠ·ã€‚`);
            showActionFeedback(`âš ï¸ ç¬¬ ${currentSet} å±€ç›®å‰å°šç„¡ç´€éŒ„å¯æ’¤éŠ·ã€‚`);
            return;
        }

        const removed = events.pop();

        saveData();
        updateAllDisplays();
        updateSetFilterOptions();
        updateSetEventLog();
        updateAnalysis();

        if (removed) {
            const skillText  = SKILL_LABELS[removed.skill]  || removed.skill;
            const resultText = RESULT_LABELS[removed.result] || removed.result;
            showActionFeedback(`â†©ï¸ å·²æ’¤éŠ·ï¼šç¬¬ ${currentSet} å±€ã€€${removed.player}ã€€${skillText}ï¼ˆ${resultText}ï¼‰`);
        }
    }

    // ===== ç•«é¢æ›´æ–° =====
    function updateAllDisplays() {
        updatePlayerSelect();
        updatePlayerListTable();
        updateStatsTable();
        updateCurrentMatchInfo();
    }

    function updatePlayerSelect() {
        const select = document.getElementById('recordPlayerSelect');
        if (!select) return;
        const current = select.value;
        select.innerHTML = '<option value="">-- è«‹é¸æ“‡çƒå“¡ --</option>';
        players.forEach(name => {
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name;
            select.appendChild(opt);
        });
        if (players.includes(current)) {
            select.value = current;
        }
    }

    function updatePlayerListTable() {
        const tbody = document.getElementById('playerListTable');
        if (!tbody) return;
        tbody.innerHTML = '';
        players.forEach(name => {
            const tr = tbody.insertRow();
            const tdName = tr.insertCell();
            const tdOp = tr.insertCell();
            tdName.textContent = name;
            tdOp.innerHTML = `<button class="delete-btn" onclick="deletePlayer('${name.replace(/'/g, "\\'")}')">åˆªé™¤</button>`;
        });
    }

    // ç›®å‰æ¯”è³½è³‡è¨Šï¼ˆé¡¯ç¤ºåœ¨æŠ€è¡“è¨˜éŒ„é ï¼‰
    function updateCurrentMatchInfo() {
        const box = document.getElementById('currentMatchInfo');
        if (!box) return;

        if (!currentMatch) {
            box.innerHTML = '<p style="color:#999;">å°šæœªé–‹å§‹æ¯”è³½ï¼Œè«‹å…ˆåœ¨ã€Œæ¯”è³½è¨­å®šã€é é¢é–‹å§‹æ–°æ¯”è³½ã€‚</p>';
            return;
        }

        const setSelect = document.getElementById('currentSet');
        const setValue = setSelect ? setSelect.value : '1';

        box.innerHTML = `
            <p><strong>æ—¥æœŸï¼š</strong>${currentMatch.date || 'â€”'}</p>
            <p><strong>åœ°é»ï¼š</strong>${currentMatch.location || 'â€”'}</p>
            <p><strong>å°æ‰‹ï¼š</strong>${currentMatch.opponent || 'â€”'}</p>
            <p style="margin-top:6px;"><strong>ç›®å‰è¨˜éŒ„å±€æ•¸ï¼š</strong>ç¬¬ ${setValue} å±€</p>
        `;
    }

    // å±€æ•¸ä¸‹æ‹‰
    function updateSetFilterOptions() {
        const select = document.getElementById('statsSetSelect');
        if (!select) return;

        const previous = currentViewSet;
        select.innerHTML = '<option value="all">å…¨éƒ¨å±€æ•¸</option>';

        if (currentMatch && currentMatch.sets) {
            Object.keys(currentMatch.sets)
                .sort((a, b) => Number(a) - Number(b))
                .forEach(setKey => {
                    const opt = document.createElement('option');
                    opt.value = setKey;
                    opt.textContent = `ç¬¬ ${setKey} å±€`;
                    select.appendChild(opt);
                });
        }

        if (Array.from(select.options).some(o => o.value === previous)) {
            select.value = previous;
            currentViewSet = previous;
        } else {
            select.value = 'all';
            currentViewSet = 'all';
        }

        updateAnalysisSetLabel();
        saveData();
    }

    function onSetFilterChange() {
        const select = document.getElementById('statsSetSelect');
        currentViewSet = select.value || 'all';
        updateAnalysisSetLabel();
        saveData();
        updateStatsTable();
        updateSetEventLog();
        updateAnalysis();
    }

    function updateAnalysisSetLabel() {
        const span = document.getElementById('analysisSetDisplay');
        if (!span) return;
        span.textContent =
            currentViewSet === 'all'
                ? 'å…¨éƒ¨å±€æ•¸'
                : `ç¬¬ ${currentViewSet} å±€`;
    }

    // çµ±è¨ˆè¡¨ + æˆåŠŸç‡
    function updateStatsTable() {
        const tbody = document.getElementById('statsTableBody');
        const rateBox = document.getElementById('successRateStats');
        if (!tbody || !rateBox) return;

        tbody.innerHTML = '';

        if (!currentMatch) {
            tbody.innerHTML =
                '<tr><td colspan="9" style="padding:12px; color:#999;">å°šæœªé–‹å§‹æ¯”è³½</td></tr>';
            rateBox.innerHTML =
                '<p style="color:#999;">å°šæœªé–‹å§‹æ¯”è³½</p>';
            return;
        }

        const stats = computeStats(currentViewSet);

        const names = Object.keys(stats);
        if (names.length === 0) {
            tbody.innerHTML =
                '<tr><td colspan="9" style="padding:12px; color:#999;">å°šç„¡ç´€éŒ„</td></tr>';
            rateBox.innerHTML =
                '<p style="color:#999;">å°šç„¡ç´€éŒ„</p>';
            return;
        }

        names.forEach(name => {
            const s = stats[name];
            const totalScore =
                s.serve.score + s.receive.score + s.attack.score +
                s.block.score + s.set.score + s.defense.score;
            const totalError =
                s.serve.error + s.receive.error + s.attack.error +
                s.block.error + s.set.error + s.defense.error;

            const tr = tbody.insertRow();
            tr.innerHTML = `
                <td>${name}</td>
                <td>${s.serve.score}/${s.serve.error}</td>
                <td>${s.receive.score}/${s.receive.error}</td>
                <td>${s.attack.score}/${s.attack.error}</td>
                <td>${s.block.score}/${s.block.error}</td>
                <td>${s.set.score}/${s.set.error}</td>
                <td>${s.defense.score}/${s.defense.error}</td>
                <td style="color:#11998e; font-weight:bold;">${totalScore}</td>
                <td style="color:#eb3349; font-weight:bold;">${totalError}</td>
            `;
        });

        updateSuccessRates(stats);
    }

    function updateSuccessRates(stats) {
        const container = document.getElementById('successRateStats');
        if (!container) return;
        container.innerHTML = '';

        const names = Object.keys(stats);
        if (names.length === 0) {
            container.innerHTML = '<p style="color:#999;">å°šç„¡ç´€éŒ„</p>';
            return;
        }

        names.forEach(name => {
            const s = stats[name];
            const skills = ['serve', 'receive', 'attack', 'block', 'set', 'defense'];
            let html = `<h3>${name}</h3>`;
            skills.forEach(sk => {
                const total = s[sk].score + s[sk].error;
                const rate = total > 0
                    ? ((s[sk].score / total) * 100).toFixed(1)
                    : '0.0';
                html += `
                    <div class="stat-row">
                        <span class="stat-label">${SKILL_LABELS[sk]}æˆåŠŸç‡</span>
                        <span class="stat-value">${rate}%</span>
                    </div>`;
            });
            container.innerHTML += `<div style="margin-bottom:20px;">${html}</div>`;
        });
    }

    // æœ¬å±€äº‹ä»¶ç´€éŒ„
    function updateSetEventLog() {
        const container = document.getElementById('setEventLog');
        if (!container) return;

        if (!currentMatch) {
            container.innerHTML =
                '<p style="color:#999; padding:10px;">å°šæœªé–‹å§‹æ¯”è³½ã€‚</p>';
            return;
        }

        if (currentViewSet === 'all') {
            container.innerHTML =
                '<p style="color:#999; padding:10px;">è«‹åœ¨ä¸Šæ–¹é¸æ“‡ç‰¹å®šå±€æ•¸ï¼Œå³å¯æŸ¥çœ‹æœ¬å±€è©³ç´°äº‹ä»¶ç´€éŒ„ã€‚</p>';
            return;
        }

        const events = (currentMatch.sets && currentMatch.sets[currentViewSet]) || [];
        if (events.length === 0) {
            container.innerHTML =
                '<p style="color:#999; padding:10px;">æœ¬å±€ç›®å‰å°šç„¡ç´€éŒ„ã€‚</p>';
            return;
        }

        let html = '';
        events.forEach((ev, idx) => {
            const t = new Date(ev.time);
            const timeStr = t.toLocaleTimeString('zh-TW', { hour12: false });
            html += `
                <div class="match-item">
                    <strong>#${idx + 1}</strong> ã€${timeStr}ã€‘<br>
                    çƒå“¡ï¼š${ev.player}<br>
                    å‹•ä½œï¼š${SKILL_LABELS[ev.skill] || ev.skill}<br>
                    çµæœï¼š${RESULT_LABELS[ev.result] || ev.result}
                </div>`;
        });
        container.innerHTML = html;
    }

    // ===== æ•¸æ“šåˆ†æ =====
    function updateAnalysis() {
        const mvpBox = document.getElementById('mvpDisplay');
        const rankingBox = document.getElementById('rankingDisplay');

        if (!currentMatch) {
            if (mvpBox) {
                mvpBox.innerHTML = '<div class="card">å°šæœªé–‹å§‹æ¯”è³½</div>';
            }
            if (rankingBox) {
                rankingBox.innerHTML = '';
            }
            if (window.skillChart) window.skillChart.destroy();
            if (window.rateChart) window.rateChart.destroy();
            return;
        }

        const stats = computeStats(currentViewSet);
        updateAnalysisSetLabel();
        calculateMVP(stats);
        displayRankings(stats);
        drawCharts(stats);
    }

    function calculateMVP(stats) {
        let mvp = null;
        let bestScore = -Infinity;

        Object.entries(stats).forEach(([name, s]) => {
            const totalScore =
                s.serve.score + s.receive.score + s.attack.score +
                s.block.score + s.set.score + s.defense.score;
            const totalError =
                s.serve.error + s.receive.error + s.attack.error +
                s.block.error + s.set.error + s.defense.error;

            const net = totalScore - totalError * 0.5;
            if (net > bestScore) {
                bestScore = net;
                mvp = name;
            }
        });

        const box = document.getElementById('mvpDisplay');
        if (!box) return;

        if (!mvp || bestScore <= -Infinity) {
            box.innerHTML = '<div class="card">å°šç„¡æ•¸æ“š</div>';
            return;
        }

        const scopeText =
            currentViewSet === 'all'
                ? 'ï¼ˆå…¨éƒ¨å±€æ•¸ï¼‰'
                : `ï¼ˆç¬¬ ${currentViewSet} å±€ï¼‰`;

        box.innerHTML = `
            <div class="mvp-card">
                ğŸ† MVP ${scopeText}ï¼š${mvp}
                <div style="font-size:0.6em; margin-top:10px;">
                    ç¶œåˆè©•åˆ†ï¼š${bestScore.toFixed(1)}
                </div>
            </div>`;
    }

    function displayRankings(stats) {
        const container = document.getElementById('rankingDisplay');
        if (!container) return;
        const skills = ['serve', 'receive', 'attack', 'block', 'set', 'defense'];
        let html = '';

        skills.forEach(sk => {
            const label = SKILL_LABELS[sk];
            const ranking = Object.entries(stats)
                .map(([name, s]) => ({
                    name,
                    score: s[sk].score
                }))
                .sort((a, b) => b.score - a.score)
                .filter(r => r.score > 0)
                .slice(0, 3);

            html += `<div style="margin-bottom:20px;">
                <h3>${label}æ’è¡Œ</h3>`;

            if (ranking.length === 0) {
                html += `
                    <div class="stat-row">
                        <span>ç›®å‰ç„¡ç´€éŒ„</span>
                        <span class="stat-value">-</span>
                    </div>`;
            } else {
                ranking.forEach((r, idx) => {
                    html += `
                        <div class="stat-row">
                            <span>${idx + 1}. ${r.name}</span>
                            <span class="stat-value">${r.score}</span>
                        </div>`;
                });
            }

            html += '</div>';
        });

        container.innerHTML = html;
    }

    function drawCharts(stats) {
        drawSkillChart(stats);
        drawRateChart(stats);
    }

    function drawSkillChart(stats) {
        const ctx = document.getElementById('skillChart');
        if (!ctx) return;
        if (window.skillChart) window.skillChart.destroy();

        const names = Object.keys(stats);
        if (names.length === 0) return;

        const skillKeys = ['serve', 'receive', 'attack', 'block', 'set', 'defense'];
        const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'];

        const datasets = skillKeys.map((sk, idx) => ({
            label: SKILL_LABELS[sk],
            data: names.map(n => stats[n][sk].score),
            backgroundColor: colors[idx]
        }));

        window.skillChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: names,
                datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: { beginAtZero: true }
                }
            }
        });
    }

    function drawRateChart(stats) {
        const ctx = document.getElementById('rateChart');
        if (!ctx) return;
        if (window.rateChart) window.rateChart.destroy();

        const names = Object.keys(stats);
        if (names.length === 0) return;

        const skillKeys = ['serve', 'receive', 'attack', 'block', 'set', 'defense'];
        const data = names.map(name => {
            const s = stats[name];
            let totalRate = 0;
            let cnt = 0;
            skillKeys.forEach(sk => {
                const total = s[sk].score + s[sk].error;
                if (total > 0) {
                    totalRate += (s[sk].score / total) * 100;
                    cnt++;
                }
            });
            return cnt > 0 ? totalRate / cnt : 0;
        });

        window.rateChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: names,
                datasets: [{
                    label: 'å¹³å‡æˆåŠŸç‡ (%)',
                    data,
                    borderColor: '#667eea',
                    backgroundColor: 'rgba(102,126,234,0.1)',
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: { beginAtZero: true, max: 100 }
                }
            }
        });
    }

    // ===== æ­·å²ç´€éŒ„åˆ—è¡¨ & å½ˆå‡ºçµ±è¨ˆ =====
    function displayMatchHistory() {
        const container = document.getElementById('matchHistory');
        if (!container) return;

        if (!matchHistory.length) {
            container.innerHTML =
                '<p style="text-align:center; color:#999; padding:20px;">å°šç„¡æ¯”è³½ç´€éŒ„</p>';
            return;
        }

        let html = '';
        matchHistory.forEach((m, idx) => {
            const setCount = m.sets ? Object.keys(m.sets).length : 0;
            let finalText = '';
            if (m.finalSets && m.finalSets.our != null && m.finalSets.opp != null) {
                finalText = `æœ€çµ‚å±€æ•¸ï¼š${m.finalSets.our} æ¯” ${m.finalSets.opp}<br>`;
            }
            html += `
                <div class="match-item">
                    <strong>æ¯”è³½ ${idx + 1}</strong><br>
                    æ—¥æœŸï¼š${m.date || 'â€”'}<br>
                    åœ°é»ï¼š${m.location || 'â€”'}<br>
                    å°æ‰‹ï¼š${m.opponent || 'â€”'}<br>
                    å±€æ•¸ï¼š${setCount} å±€<br>
                    ${finalText}
                    <div style="margin-top:8px; display:flex; flex-wrap:wrap; gap:8px;">
                        <button class="btn-primary"
                            style="padding:6px 10px; font-size:12px;"
                            onclick="showHistoryStats(${idx})">æŸ¥çœ‹çµ±è¨ˆ</button>
                        <button class="btn-info"
                            style="padding:6px 10px; font-size:12px;"
                            onclick="loadMatchFromHistory(${idx})">è¼‰å…¥é€™å ´æ¯”è³½</button>
                        <button class="delete-btn"
                            onclick="deleteMatch(${idx})">åˆªé™¤</button>
                    </div>
                </div>`;
        });

        container.innerHTML = html;
    }

    // ===== Supabase åŒæ­¥å‡½å¼ =====
    async function saveMatchToSupabase(match) {
        try {
            const { error } = await supabase
                .from('volleyball_matches')
                .upsert({
                    id: match.id,
                    data: match
                });

            if (error) {
                console.error('å„²å­˜åˆ° Supabase å¤±æ•—', error);
                alert('é›²ç«¯å„²å­˜å¤±æ•—ï¼Œä½†æœ¬æ©Ÿå·²ç¶“æœ‰ç´€éŒ„ã€‚');
            } else {
                console.log('å·²å„²å­˜åˆ° Supabase');
            }
        } catch (e) {
            console.error('å‘¼å« Supabase æ™‚ç™¼ç”ŸéŒ¯èª¤', e);
        }
    }

    async function loadMatchHistoryFromSupabase() {
        try {
            const { data, error } = await supabase
                .from('volleyball_matches')
                .select('*')
                .order('created_at', { ascending: false });

            if (error) {
                console.error('è®€å– Supabase æ­·å²å¤±æ•—', error);
                return;
            }

            matchHistory = (data || []).map(row => row.data);

        
            displayMatchHistory();

            console.log('å·²å¾ Supabase è¼‰å…¥æ­·å²æ¯”è³½');
        } catch (e) {
            console.error('å‘¼å« Supabase æ™‚ç™¼ç”ŸéŒ¯èª¤', e);
        }
    }

    async function deleteMatchFromSupabase(matchId) {
        try {
            const { error } = await supabase
                .from('volleyball_matches')
                .delete()
                .eq('id', matchId);

            if (error) {
                console.error('åˆªé™¤ Supabase è³‡æ–™å¤±æ•—', error);
            }
        } catch (e) {
            console.error('å‘¼å« Supabase åˆªé™¤æ™‚éŒ¯èª¤', e);
        }
    }

    async function clearSupabaseHistory() {
        try {
            const { error } = await supabase
                .from('volleyball_matches')
                .delete()
                .neq('id', 0);

            if (error) {
                console.error('æ¸…é™¤ Supabase æ­·å²å¤±æ•—', error);
            }
        } catch (e) {
            console.error('å‘¼å« Supabase æ¸…é™¤æ™‚éŒ¯èª¤', e);
        }
    }

    // é¡¯ç¤ºæ­·å²æ¯”è³½çµ±è¨ˆå½ˆçª—
    function showHistoryStats(idx, viewSet) {
        const modal = document.getElementById('historyModal');
        const content = document.getElementById('historyModalContent');
        const match = matchHistory[idx];
        if (!modal || !content || !match) return;

        currentHistoryIdx = idx;
        currentHistoryViewSet = viewSet || currentHistoryViewSet || 'all';

        const sets = match.sets || {};
        const setKeys = Object.keys(sets).sort((a,b) => Number(a) - Number(b));

        let setOptions = `<option value="all"${currentHistoryViewSet === 'all' ? ' selected' : ''}>å…¨éƒ¨å±€æ•¸</option>`;
        setKeys.forEach(k => {
            const selected = String(currentHistoryViewSet) === String(k) ? ' selected' : '';
            setOptions += `<option value="${k}"${selected}>ç¬¬ ${k} å±€</option>`;
        });

        const stats = computeStatsForMatch(match, currentHistoryViewSet);
        const names = Object.keys(stats);

        let tableHtml = '';
        if (!names.length) {
            tableHtml = '<p style="color:#999; margin-top:10px;">å°šç„¡ç´€éŒ„</p>';
        } else {
            tableHtml += `
                <div style="overflow-x:auto;">
                    <table style="width:100%; border-collapse:collapse; margin-top:10px;">
                        <thead>
                            <tr>
                                <th>çƒå“¡</th>
                                <th>ç™¼çƒ</th>
                                <th>æ¥ç™¼</th>
                                <th>æ”»æ“Š</th>
                                <th>æ””ç¶²</th>
                                <th>èˆ‰çƒ</th>
                                <th>é˜²å®ˆ</th>
                                <th>ç¸½å¾—åˆ†</th>
                                <th>ç¸½å¤±èª¤</th>
                            </tr>
                        </thead>
                        <tbody>`;

            names.forEach(name => {
                const s = stats[name];
                const totalScore =
                    s.serve.score + s.receive.score + s.attack.score +
                    s.block.score + s.set.score + s.defense.score;
                const totalError =
                    s.serve.error + s.receive.error + s.attack.error +
                    s.block.error + s.set.error + s.defense.error;

                tableHtml += `
                    <tr>
                        <td>${name}</td>
                        <td>${s.serve.score}/${s.serve.error}</td>
                        <td>${s.receive.score}/${s.receive.error}</td>
                        <td>${s.attack.score}/${s.attack.error}</td>
                        <td>${s.block.score}/${s.block.error}</td>
                        <td>${s.set.score}/${s.set.error}</td>
                        <td>${s.defense.score}/${s.defense.error}</td>
                        <td style="color:#11998e; font-weight:bold;">${totalScore}</td>
                        <td style="color:#eb3349; font-weight:bold;">${totalError}</td>
                    </tr>`;
            });

            tableHtml += `
                        </tbody>
                    </table>
                </div>`;
        }

        const scopeText =
            currentHistoryViewSet === 'all'
                ? 'å…¨éƒ¨å±€æ•¸'
                : `ç¬¬ ${currentHistoryViewSet} å±€`;

        content.innerHTML = `
            <h2 style="color:#667eea; margin-bottom:10px;">æ­·å²æ¯”è³½çµ±è¨ˆ</h2>
            <p><strong>æ—¥æœŸï¼š</strong>${match.date || 'â€”'}</p>
            <p><strong>åœ°é»ï¼š</strong>${match.location || 'â€”'}</p>
            <p><strong>å°æ‰‹ï¼š</strong>${match.opponent || 'â€”'}</p>
            <p style="margin-top:6px;"><strong>ç›®å‰é¡¯ç¤ºï¼š</strong>${scopeText}</p>
            <div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                <label for="historySetSelect" style="font-weight:bold;">é¡¯ç¤ºå±€æ•¸ï¼š</label>
                <select id="historySetSelect" onchange="onHistorySetChange()">
                    ${setOptions}
                </select>
            </div>
            ${tableHtml}
        `;

        modal.style.display = 'flex';
    }

    function onHistorySetChange() {
        const sel = document.getElementById('historySetSelect');
        if (!sel) return;
        currentHistoryViewSet = sel.value || 'all';
        if (currentHistoryIdx !== null) {
            showHistoryStats(currentHistoryIdx, currentHistoryViewSet);
        }
    }

    function closeHistoryModal() {
        const modal = document.getElementById('historyModal');
        if (modal) modal.style.display = 'none';
    }

    function onHistoryModalBackgroundClick(e) {
        if (e.target && e.target.id === 'historyModal') {
            closeHistoryModal();
        }
    }

    function loadMatchFromHistory(idx) {
        const m = matchHistory[idx];
        if (!m) return;
        currentMatch = JSON.parse(JSON.stringify(m));
        players = Array.isArray(m.players) ? [...m.players] : [];
        currentViewSet = 'all';

        saveData();
        updateAllDisplays();
        updateSetFilterOptions();
        updateSetEventLog();
        updateAnalysis();
        updateCurrentMatchInfo();
        alert('å·²è¼‰å…¥æ­·å²æ¯”è³½ï¼Œç¾åœ¨é¡¯ç¤ºçš„æ˜¯è©²å ´æ•¸æ“šã€‚');
    }

    function deleteMatch(idx) {
        if (!confirm('ç¢ºå®šè¦åˆªé™¤æ­¤æ¯”è³½ç´€éŒ„å—ï¼Ÿ')) return;

        const match = matchHistory[idx];
        if (match && match.id) {
            deleteMatchFromSupabase(match.id);  // ä¸ç­‰å®ƒå›ä¾†ï¼Œç›´æ¥è®“ç•«é¢å…ˆæ›´æ–°
        }

        matchHistory.splice(idx, 1);
        saveData();
        displayMatchHistory();
    }

    function clearHistory() {
        if (!confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ­·å²ç´€éŒ„å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸï¼')) return;

        clearSupabaseHistory();

        matchHistory = [];
        saveData();
        displayMatchHistory();
    }
</script>

<!-- Supabase JSï¼ˆä¸€å®šè¦åœ¨æœ€å¾Œè¼‰å…¥ï¼‰ -->
<script src="https://unpkg.com/@supabase/supabase-js@2.48.0/dist/umd/supabase.min.js"></script>
<script>
    const supabaseUrl = 'https://wwdehrjogondnemmazfc.supabase.co';
    const supabaseKey = 'sb_publishable_bH3G1mBpFakJjyUS5KaPWA_jHNBTLub'; // æ›¿æ›æˆä½ çš„ anon key
    const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);
</script>
</body>
</html>
