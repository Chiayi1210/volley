<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ’çƒæŠ€è¡“çµ±è¨ˆå¹³å°</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 12px 24px;
            background: rgba(49, 86, 116, 0.9);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            color: #fff;
        }

        .tab-btn.active {
            background: rgb(0, 0, 0);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transform: translateY(-2px);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 15px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        .action-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .btn-success { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }
        .btn-danger { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); }
        .btn-warning { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .btn-info { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        th, td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #eee;
            align-items: center;
        }

        .stat-label {
            font-weight: bold;
            color: #555;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #667eea;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin: 20px 0;
        }

        .mvp-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            font-size: 1.5em;
            margin: 20px 0;
        }

        .skill-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .skill-btn {
            padding: 15px;
            font-size: 14px;
        }

        .match-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .match-item {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .delete-btn {
            background: #e74c3c;
            padding: 5px 10px;
            font-size: 12px;
        }

        @media (max-width: 768px) {
            .form-grid, .action-grid {
                grid-template-columns: 1fr;
            }
            .chart-container {
                height: 300px;
            }
            .skill-buttons {
                grid-template-columns: 1fr;
            }
        }

        /* æ­·å²çµ±è¨ˆå½ˆå‡ºè¦–çª— */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-card {
            background: #fff;
            border-radius: 12px;
            max-width: 900px;
            width: 95%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .modal-close {
            text-align: right;
            margin-bottom: 10px;
        }

        .modal-close button {
            background: #e74c3c;
            border-radius: 20px;
            padding: 6px 12px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ æ’çƒæŠ€è¡“çµ±è¨ˆå¹³å°</h1>

        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab(event, 'match')">æ¯”è³½è¨­å®š</button>
            <button class="tab-btn" onclick="switchTab(event, 'record')">æŠ€è¡“è¨˜éŒ„</button>
            <button class="tab-btn" onclick="switchTab(event, 'stats')">æ•¸æ“šçµ±è¨ˆ</button>
            <button class="tab-btn" onclick="switchTab(event, 'analysis')">æ•¸æ“šåˆ†æ</button>
            <button class="tab-btn" onclick="switchTab(event, 'history')">æ­·å²ç´€éŒ„</button>
        </div>

        <!-- æ¯”è³½è¨­å®š -->
        <div id="tab-match" class="tab-content active">
            <div class="card">
                <h2>æ¯”è³½è³‡è¨Šè¨­å®š</h2>
                <div class="form-grid">
                    <div class="input-group">
                        <label>æ¯”è³½æ—¥æœŸ</label>
                        <input type="date" id="matchDate">
                    </div>
                    <div class="input-group">
                        <label>æ¯”è³½åœ°é»</label>
                        <input type="text" id="matchLocation" placeholder="è¼¸å…¥æ¯”è³½åœ°é»">
                    </div>
                    <div class="input-group">
                        <label>å°æ‰‹éšŠä¼</label>
                        <input type="text" id="opponentTeam" placeholder="è¼¸å…¥å°æ‰‹éšŠå">
                    </div>
                    <div class="input-group">
                        <label>ç•¶å‰å±€æ•¸</label>
                        <select id="currentSet">
                            <option value="1">ç¬¬ä¸€å±€</option>
                            <option value="2">ç¬¬äºŒå±€</option>
                            <option value="3">ç¬¬ä¸‰å±€</option>
                            <option value="4">ç¬¬å››å±€</option>
                            <option value="5">ç¬¬äº”å±€</option>
                        </select>
                    </div>
                </div>
                <div class="action-grid">
                    <button class="btn-primary" onclick="startMatch()">é–‹å§‹æ–°æ¯”è³½</button>
                    <button class="btn-warning" onclick="finishMatch()">çµæŸæœ¬å ´æ¯”è³½ä¸¦å­˜å…¥æ­·å²</button>
                </div>
            </div>

            <div class="card">
                <h2>çƒå“¡ç®¡ç†</h2>
                <div class="input-group">
                    <label>æ–°å¢çƒå“¡</label>
                    <input type="text" id="playerName" placeholder="è¼¸å…¥çƒå“¡å§“åæˆ–èƒŒè™Ÿ">
                </div>
                <button class="btn-success" onclick="addPlayer()">â• æ–°å¢çƒå“¡</button>
                
                <table>
                    <thead>
                        <tr>
                            <th>çƒå“¡</th>
                            <th>æ“ä½œ</th>
                        </tr>
                    </thead>
                    <tbody id="playerListTable"></tbody>
                </table>
            </div>
        </div>

        <!-- æŠ€è¡“è¨˜éŒ„ -->
        <div id="tab-record" class="tab-content">
            <!-- ç›®å‰æ¯”è³½è³‡è¨Šé¡¯ç¤º -->
            <div class="card">
                <h2>ç›®å‰æ¯”è³½è³‡è¨Š</h2>
                <div id="currentMatchInfo"></div>
            </div>

            <div class="card">
                <h2>é¸æ“‡çƒå“¡</h2>
                <select id="recordPlayerSelect">
                    <option value="">-- è«‹é¸æ“‡çƒå“¡ --</option>
                </select>
            </div>

            <div class="card">
                <h2>æŠ€è¡“å‹•ä½œè¨˜éŒ„</h2>
                <div class="skill-buttons">
                    <button class="btn-success skill-btn" onclick="recordAction('serve', 'score')">ğŸ¾ ç™¼çƒå¾—åˆ†</button>
                    <button class="btn-danger skill-btn" onclick="recordAction('serve', 'error')">ğŸ¾ ç™¼çƒå¤±èª¤</button>
                    
                    <button class="btn-success skill-btn" onclick="recordAction('receive', 'score')">ğŸ“¥ æ¥ç™¼å¾—åˆ†</button>
                    <button class="btn-danger skill-btn" onclick="recordAction('receive', 'error')">ğŸ“¥ æ¥ç™¼å¤±èª¤</button>
                    
                    <button class="btn-success skill-btn" onclick="recordAction('attack', 'score')">âš¡ æ”»æ“ŠæˆåŠŸ</button>
                    <button class="btn-danger skill-btn" onclick="recordAction('attack', 'error')">âš¡ æ”»æ“Šå¤±èª¤</button>
                    
                    <button class="btn-success skill-btn" onclick="recordAction('block', 'score')">ğŸ›¡ï¸ æ””ç¶²å¾—åˆ†</button>
                    <button class="btn-danger skill-btn" onclick="recordAction('block', 'error')">ğŸ›¡ï¸ æ””ç¶²å¤±èª¤</button>
                    
                    <button class="btn-success skill-btn" onclick="recordAction('set', 'score')">ğŸ¤² èˆ‰çƒå¾—åˆ†</button>
                    <button class="btn-danger skill-btn" onclick="recordAction('set', 'error')">ğŸ¤² èˆ‰çƒå¤±èª¤</button>
                    
                    <button class="btn-success skill-btn" onclick="recordAction('defense', 'score')">ğŸ›Ÿ é˜²å®ˆæˆåŠŸ</button>
                    <button class="btn-danger skill-btn" onclick="recordAction('defense', 'error')">ğŸ›Ÿ é˜²å®ˆå¤±èª¤</button>
                </div>
            </div>
        </div>

        <!-- æ•¸æ“šçµ±è¨ˆ -->
        <div id="tab-stats" class="tab-content">
            <div class="card">
                <h2>çƒå“¡æŠ€è¡“çµ±è¨ˆ</h2>

                <!-- å±€æ•¸ç¯©é¸ -->
                <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:10px;">
                    <label for="statsSetSelect" style="font-weight:bold;">é¡¯ç¤ºå±€æ•¸ï¼š</label>
                    <select id="statsSetSelect" onchange="onSetFilterChange()">
                        <option value="all">å…¨éƒ¨å±€æ•¸</option>
                    </select>
                </div>

                <div style="overflow-x: auto;">
                    <table id="statsTable">
                        <thead>
                            <tr>
                                <th>çƒå“¡</th>
                                <th>ç™¼çƒ</th>
                                <th>æ¥ç™¼</th>
                                <th>æ”»æ“Š</th>
                                <th>æ””ç¶²</th>
                                <th>èˆ‰çƒ</th>
                                <th>é˜²å®ˆ</th>
                                <th>ç¸½å¾—åˆ†</th>
                                <th>ç¸½å¤±èª¤</th>
                            </tr>
                        </thead>
                        <tbody id="statsTableBody"></tbody>
                    </table>
                </div>
            </div>

            <div class="card">
                <h2>æˆåŠŸç‡çµ±è¨ˆ</h2>
                <div id="successRateStats"></div>
            </div>

            <!-- æœ¬å±€äº‹ä»¶ç´€éŒ„ -->
            <div class="card">
                <h2>æœ¬å±€äº‹ä»¶ç´€éŒ„</h2>
                <div id="setEventLog" class="match-list"></div>
            </div>
        </div>

        <!-- æ•¸æ“šåˆ†æ -->
        <div id="tab-analysis" class="tab-content">
            <div class="card">
                <h2>åˆ†æè¨­å®š</h2>
                <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                    <label style="font-weight:bold;">ç›®å‰åˆ†æå±€æ•¸ï¼š</label>
                    <span id="analysisSetDisplay">å…¨éƒ¨å±€æ•¸</span>
                </div>
            </div>

            <div id="mvpDisplay"></div>

            <div class="card">
                <h2>å„é …æŠ€è¡“æ’å</h2>
                <div id="rankingDisplay"></div>
            </div>

            <div class="card">
                <h2>æŠ€è¡“çµ±è¨ˆåœ–è¡¨</h2>
                <div class="chart-container">
                    <canvas id="skillChart"></canvas>
                </div>
            </div>

            <div class="card">
                <h2>æˆåŠŸç‡åœ–è¡¨</h2>
                <div class="chart-container">
                    <canvas id="rateChart"></canvas>
                </div>
            </div>
        </div>

        <!-- æ­·å²ç´€éŒ„ -->
        <div id="tab-history" class="tab-content">
            <div class="card">
                <h2>æ¯”è³½æ­·å²</h2>
                <div class="action-grid">
                    <button class="btn-danger" onclick="clearHistory()">æ¸…é™¤æ‰€æœ‰æ­·å²</button>
                </div>
                <div class="match-list" id="matchHistory"></div>
            </div>
        </div>
    </div>

    <!-- æ­·å²çµ±è¨ˆå½ˆå‡ºè¦–çª— -->
    <div id="historyModal" class="modal-overlay" onclick="onHistoryModalBackgroundClick(event)">
        <div class="modal-card">
            <div class="modal-close">
                <button onclick="closeHistoryModal()">é—œé–‰</button>
            </div>
            <div id="historyModalContent"></div>
        </div>
    </div>

    <script>
        // ===== ç‹€æ…‹è®Šæ•¸ =====
        let currentMatch = null;     // ç›®å‰é€²è¡Œä¸­çš„æ¯”è³½
        let players = [];            // ç›®å‰æ¯”è³½çš„çƒå“¡æ¸…å–®ï¼ˆé™£åˆ—ï¼‰
        let matchHistory = [];       // æ­·å²æ¯”è³½
        let currentViewSet = 'all';  // stats / analysis ç›®å‰é¡¯ç¤ºçš„å±€æ•¸

        // æ­·å²è¦–çª—ç”¨
        let currentHistoryIdx = null;
        let currentHistoryViewSet = 'all';

        // æŠ€è¡“èˆ‡çµæœå°ç…§
        const SKILL_LABELS = {
            serve: 'ç™¼çƒ',
            receive: 'æ¥ç™¼',
            attack: 'æ”»æ“Š',
            block: 'æ””ç¶²',
            set: 'èˆ‰çƒ',
            defense: 'é˜²å®ˆ'
        };
        const RESULT_LABELS = {
            score: 'æˆåŠŸ',
            error: 'å¤±èª¤'
        };

        // ===== è¼‰å…¥ / å„²å­˜ =====
        function loadData() {
            const saved = localStorage.getItem('volleyballStatsV2');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    currentMatch   = data.currentMatch || null;
                    players        = data.players || [];
                    matchHistory   = data.matchHistory || [];
                    currentViewSet = data.currentViewSet || 'all';
                } catch (e) {
                    console.error('è®€å– localStorage å¤±æ•—ï¼Œæ¸…é™¤èˆŠè³‡æ–™', e);
                    localStorage.removeItem('volleyballStatsV2');
                }
            }
        }

        function saveData() {
            const data = {
                currentMatch,
                players,
                matchHistory,
                currentViewSet
            };
            localStorage.setItem('volleyballStatsV2', JSON.stringify(data));
        }

        window.onload = function() {
            loadData();  // ä¿ç•™èˆŠçš„æœ¬æ©Ÿè³‡æ–™ï¼ˆé›¢ç·šç”¨ï¼‰
            document.getElementById('matchDate').valueAsDate = new Date();
            updateAllDisplays();
            updateSetFilterOptions();
            updateSetEventLog();
            updateAnalysis();
            updateCurrentMatchInfo();

            const setSelect = document.getElementById('currentSet');
            if (setSelect) {
                setSelect.addEventListener('change', () => {
                    updateCurrentMatchInfo();
                });
            }

    // â˜… æ–°å¢ï¼šä¸€è¼‰å…¥é é¢å°±å» Supabase æŠ“æœ€æ–°çš„æ­·å²æ¯”è³½
    loadMatchHistoryFromSupabase();
};

        // ===== å…±ç”¨ UI =====
        function switchTab(e, tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');
            if (e && e.target) e.target.classList.add('active');

            if (tabName === 'stats') {
                updateStatsTable();
            } else if (tabName === 'analysis') {
                updateAnalysis();
            } else if (tabName === 'history') {
                displayMatchHistory();
            }
        }

        function createEmptyStats() {
            return {
                serve:   { score: 0, error: 0 },
                receive: { score: 0, error: 0 },
                attack:  { score: 0, error: 0 },
                block:   { score: 0, error: 0 },
                set:     { score: 0, error: 0 },
                defense: { score: 0, error: 0 }
            };
        }

        // æ ¹æ“š currentMatch çš„ events + players è¨ˆç®—æŸä¸€å±€ï¼ˆæˆ–å…¨éƒ¨ï¼‰çµ±è¨ˆ
        function computeStats(viewSet = 'all') {
            const stats = {};
            // å…ˆæŠŠæ‰€æœ‰çƒå“¡å»ºå¥½ 0
            players.forEach(name => {
                stats[name] = createEmptyStats();
            });

            if (!currentMatch || !currentMatch.sets) return stats;

            const setKeys = viewSet === 'all'
                ? Object.keys(currentMatch.sets || {})
                : [viewSet];

            setKeys.forEach(setKey => {
                const events = currentMatch.sets[setKey] || [];
                events.forEach(ev => {
                    const { player, skill, result } = ev;
                    if (!stats[player]) {
                        stats[player] = createEmptyStats();
                    }
                    if (stats[player][skill]) {
                        stats[player][skill][result]++;
                    }
                });
            });

            return stats;
        }

        // çµ¦æ­·å²æ¯”è³½ç”¨çš„ stats è¨ˆç®—
        function computeStatsForMatch(match, viewSet = 'all') {
            const stats = {};
            if (!match || !match.sets) return stats;

            const setKeys = viewSet === 'all'
                ? Object.keys(match.sets || {})
                : [viewSet];

            setKeys.forEach(setKey => {
                const events = match.sets[setKey] || [];
                events.forEach(ev => {
                    const { player, skill, result } = ev;
                    if (!stats[player]) {
                        stats[player] = createEmptyStats();
                    }
                    if (stats[player][skill]) {
                        stats[player][skill][result]++;
                    }
                });
            });

            return stats;
        }

        // ===== æ¯”è³½æ§åˆ¶ =====
        function startMatch() {
            const date = document.getElementById('matchDate').value;
            const location = document.getElementById('matchLocation').value.trim();
            const opponent = document.getElementById('opponentTeam').value.trim();

            if (!date || !location || !opponent) {
                alert('è«‹å¡«å¯«å®Œæ•´çš„æ¯”è³½è³‡è¨Šï¼');
                return;
            }

            // è‹¥å·²æœ‰é€²è¡Œä¸­çš„æ¯”è³½
            if (currentMatch) {
                const hasEvents = currentMatch.sets &&
                    Object.values(currentMatch.sets).some(arr => arr && arr.length > 0);

                if (hasEvents) {
                    const ok = confirm('ç›®å‰æœ‰ä¸€å ´å°šæœªçµæŸçš„æ¯”è³½ï¼Œé–‹å§‹æ–°æ¯”è³½å‰è¦å…ˆæŠŠèˆŠæ¯”è³½å­˜å…¥æ­·å²ç´€éŒ„å—ï¼Ÿ');
                    if (ok) {
                        const snapshot = JSON.parse(JSON.stringify(currentMatch));
                        snapshot.players = [...players];
                        matchHistory.push(snapshot);
                    }
                }
            }

            // é–‹æ–°æ¯”è³½ï¼ˆæ¸…ç©ºçƒå“¡èˆ‡å±€æ•¸ï¼‰
            currentMatch = {
                id: Date.now(),
                date,
                location,
                opponent,
                startTime: new Date().toISOString(),
                sets: {} // { "1": [ events... ], "2": [...] }
            };
            players = [];
            currentViewSet = 'all';

            saveData();
            updateAllDisplays();
            updateSetFilterOptions();
            updateSetEventLog();
            updateAnalysis();
            updateCurrentMatchInfo();

            alert('æ¯”è³½å·²é–‹å§‹ï¼è«‹åˆ‡æ›åˆ°ã€ŒæŠ€è¡“è¨˜éŒ„ã€é é¢é–‹å§‹è¨˜éŒ„ã€‚');
        }

        async function finishMatch() {
            if (!currentMatch) {
                alert('ç›®å‰æ²’æœ‰é€²è¡Œä¸­çš„æ¯”è³½ã€‚');
                return;
            }

            const hasEvents = currentMatch.sets &&
                Object.values(currentMatch.sets).some(arr => arr && arr.length > 0);

            if (!hasEvents) {
                if (!confirm('é€™å ´æ¯”è³½é‚„æ²’æœ‰ä»»ä½•ç´€éŒ„ï¼Œä»è¦çµæŸä¸¦å­˜å…¥æ­·å²å—ï¼Ÿ')) {
                    return;
                }
            }

            const snapshot = JSON.parse(JSON.stringify(currentMatch));
            snapshot.players = [...players];

            // æ”¾é€²æœ¬æ©Ÿçš„æ­·å²
            matchHistory.push(snapshot);

            // â˜… æ–°å¢ï¼šåŒæ­¥åˆ° Supabase
            await saveMatchToSupabase(snapshot);

            // æ¸…ç©ºç›®å‰æ¯”è³½
            currentMatch = null;
            players = [];
            currentViewSet = 'all';

            saveData();
            updateAllDisplays();
            updateSetFilterOptions();
            updateSetEventLog();
            updateAnalysis();
            displayMatchHistory();
            updateCurrentMatchInfo();

            alert('æœ¬å ´æ¯”è³½å·²å„²å­˜åˆ°æ­·å²ç´€éŒ„ï¼ˆå«é›²ç«¯ï¼‰ï¼');
        }

        // ===== çƒå“¡ç®¡ç† =====
        function addPlayer() {
            const input = document.getElementById('playerName');
            const name = input.value.trim();
            if (!name) {
                alert('è«‹è¼¸å…¥çƒå“¡å§“åæˆ–èƒŒè™Ÿï¼');
                return;
            }
            if (players.includes(name)) {
                alert('æ­¤çƒå“¡å·²å­˜åœ¨ï¼');
                return;
            }
            players.push(name);
            input.value = '';
            saveData();
            updateAllDisplays();
            alert(`çƒå“¡ã€Œ${name}ã€æ–°å¢æˆåŠŸï¼`);
        }

        function deletePlayer(name) {
            if (!confirm(`ç¢ºå®šè¦åˆªé™¤çƒå“¡ã€Œ${name}ã€å—ï¼Ÿ`)) return;
            players = players.filter(p => p !== name);

            // åˆªé™¤ç¾æœ‰å±€æ•¸ä¸­çš„è©²çƒå“¡äº‹ä»¶
            if (currentMatch && currentMatch.sets) {
                Object.keys(currentMatch.sets).forEach(setKey => {
                    currentMatch.sets[setKey] =
                        (currentMatch.sets[setKey] || []).filter(ev => ev.player !== name);
                });
            }

            saveData();
            updateAllDisplays();
            updateSetEventLog();
            updateAnalysis();
        }

        // ===== è¨˜éŒ„å‹•ä½œ =====
        function recordAction(skill, result) {
            const playerName = document.getElementById('recordPlayerSelect').value;

            if (!playerName) {
                alert('è«‹å…ˆé¸æ“‡çƒå“¡ï¼');
                return;
            }

            if (!currentMatch) {
                alert('è«‹å…ˆåœ¨ã€Œæ¯”è³½è¨­å®šã€é é¢é–‹å§‹æ–°æ¯”è³½ï¼');
                return;
            }

            if (!players.includes(playerName)) {
                players.push(playerName);
            }

            const currentSet = document.getElementById('currentSet').value || '1';

            if (!currentMatch.sets[currentSet]) {
                currentMatch.sets[currentSet] = [];
            }

            currentMatch.sets[currentSet].push({
                player: playerName,
                skill,
                result,
                time: new Date().toISOString()
            });

            saveData();
            updateAllDisplays();
            updateSetFilterOptions();
            updateSetEventLog();
            updateAnalysis();
        }

        // ===== ç•«é¢æ›´æ–° =====
        function updateAllDisplays() {
            updatePlayerSelect();
            updatePlayerListTable();
            updateStatsTable();
            updateCurrentMatchInfo();
        }

        function updatePlayerSelect() {
            const select = document.getElementById('recordPlayerSelect');
            const current = select.value;
            select.innerHTML = '<option value="">-- è«‹é¸æ“‡çƒå“¡ --</option>';
            players.forEach(name => {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                select.appendChild(opt);
            });
            if (players.includes(current)) {
                select.value = current;
            }
        }

        function updatePlayerListTable() {
            const tbody = document.getElementById('playerListTable');
            tbody.innerHTML = '';
            players.forEach(name => {
                const tr = tbody.insertRow();
                const tdName = tr.insertCell();
                const tdOp = tr.insertCell();
                tdName.textContent = name;
                tdOp.innerHTML = `<button class="delete-btn" onclick="deletePlayer('${name.replace(/'/g, "\\'")}')">åˆªé™¤</button>`;
            });
        }

        // ç›®å‰æ¯”è³½è³‡è¨Šï¼ˆé¡¯ç¤ºåœ¨æŠ€è¡“è¨˜éŒ„é ï¼‰
        function updateCurrentMatchInfo() {
            const box = document.getElementById('currentMatchInfo');
            if (!box) return;

            if (!currentMatch) {
                box.innerHTML = '<p style="color:#999;">å°šæœªé–‹å§‹æ¯”è³½ï¼Œè«‹å…ˆåœ¨ã€Œæ¯”è³½è¨­å®šã€é é¢é–‹å§‹æ–°æ¯”è³½ã€‚</p>';
                return;
            }

            const setSelect = document.getElementById('currentSet');
            const setValue = setSelect ? setSelect.value : '1';

            box.innerHTML = `
                <p><strong>æ—¥æœŸï¼š</strong>${currentMatch.date || 'â€”'}</p>
                <p><strong>åœ°é»ï¼š</strong>${currentMatch.location || 'â€”'}</p>
                <p><strong>å°æ‰‹ï¼š</strong>${currentMatch.opponent || 'â€”'}</p>
                <p style="margin-top:6px;"><strong>ç›®å‰è¨˜éŒ„å±€æ•¸ï¼š</strong>ç¬¬ ${setValue} å±€</p>
            `;
        }

        // å±€æ•¸ä¸‹æ‹‰
        function updateSetFilterOptions() {
            const select = document.getElementById('statsSetSelect');
            if (!select) return;

            const previous = currentViewSet;
            select.innerHTML = '<option value="all">å…¨éƒ¨å±€æ•¸</option>';

            if (currentMatch && currentMatch.sets) {
                Object.keys(currentMatch.sets)
                    .sort((a, b) => Number(a) - Number(b))
                    .forEach(setKey => {
                        const opt = document.createElement('option');
                        opt.value = setKey;
                        opt.textContent = `ç¬¬ ${setKey} å±€`;
                        select.appendChild(opt);
                    });
            }

            if (Array.from(select.options).some(o => o.value === previous)) {
                select.value = previous;
                currentViewSet = previous;
            } else {
                select.value = 'all';
                currentViewSet = 'all';
            }

            updateAnalysisSetLabel();
            saveData();
        }

        function onSetFilterChange() {
            const select = document.getElementById('statsSetSelect');
            currentViewSet = select.value || 'all';
            updateAnalysisSetLabel();
            saveData();
            updateStatsTable();
            updateSetEventLog();
            updateAnalysis();
        }

        function updateAnalysisSetLabel() {
            const span = document.getElementById('analysisSetDisplay');
            if (!span) return;
            span.textContent =
                currentViewSet === 'all'
                    ? 'å…¨éƒ¨å±€æ•¸'
                    : `ç¬¬ ${currentViewSet} å±€`;
        }

        // çµ±è¨ˆè¡¨ + æˆåŠŸç‡
        function updateStatsTable() {
            const tbody = document.getElementById('statsTableBody');
            tbody.innerHTML = '';

            if (!currentMatch) {
                tbody.innerHTML =
                    '<tr><td colspan="9" style="padding:12px; color:#999;">å°šæœªé–‹å§‹æ¯”è³½</td></tr>';
                document.getElementById('successRateStats').innerHTML =
                    '<p style="color:#999;">å°šæœªé–‹å§‹æ¯”è³½</p>';
                return;
            }

            const stats = computeStats(currentViewSet);

            const names = Object.keys(stats);
            if (names.length === 0) {
                tbody.innerHTML =
                    '<tr><td colspan="9" style="padding:12px; color:#999;">å°šç„¡ç´€éŒ„</td></tr>';
                document.getElementById('successRateStats').innerHTML =
                    '<p style="color:#999;">å°šç„¡ç´€éŒ„</p>';
                return;
            }

            names.forEach(name => {
                const s = stats[name];
                const totalScore =
                    s.serve.score + s.receive.score + s.attack.score +
                    s.block.score + s.set.score + s.defense.score;
                const totalError =
                    s.serve.error + s.receive.error + s.attack.error +
                    s.block.error + s.set.error + s.defense.error;

                const tr = tbody.insertRow();
                tr.innerHTML = `
                    <td>${name}</td>
                    <td>${s.serve.score}/${s.serve.error}</td>
                    <td>${s.receive.score}/${s.receive.error}</td>
                    <td>${s.attack.score}/${s.attack.error}</td>
                    <td>${s.block.score}/${s.block.error}</td>
                    <td>${s.set.score}/${s.set.error}</td>
                    <td>${s.defense.score}/${s.defense.error}</td>
                    <td style="color:#11998e; font-weight:bold;">${totalScore}</td>
                    <td style="color:#eb3349; font-weight:bold;">${totalError}</td>
                `;
            });

            updateSuccessRates(stats);
        }

        function updateSuccessRates(stats) {
            const container = document.getElementById('successRateStats');
            container.innerHTML = '';

            const names = Object.keys(stats);
            if (names.length === 0) {
                container.innerHTML = '<p style="color:#999;">å°šç„¡ç´€éŒ„</p>';
                return;
            }

            names.forEach(name => {
                const s = stats[name];
                const skills = ['serve', 'receive', 'attack', 'block', 'set', 'defense'];
                let html = `<h3>${name}</h3>`;
                skills.forEach(sk => {
                    const total = s[sk].score + s[sk].error;
                    const rate = total > 0
                        ? ((s[sk].score / total) * 100).toFixed(1)
                        : '0.0';
                    html += `
                        <div class="stat-row">
                            <span class="stat-label">${SKILL_LABELS[sk]}æˆåŠŸç‡</span>
                            <span class="stat-value">${rate}%</span>
                        </div>`;
                });
                container.innerHTML += `<div style="margin-bottom:20px;">${html}</div>`;
            });
        }

        // æœ¬å±€äº‹ä»¶ç´€éŒ„
        function updateSetEventLog() {
            const container = document.getElementById('setEventLog');
            if (!container) return;

            if (!currentMatch) {
                container.innerHTML =
                    '<p style="color:#999; padding:10px;">å°šæœªé–‹å§‹æ¯”è³½ã€‚</p>';
                return;
            }

            if (currentViewSet === 'all') {
                container.innerHTML =
                    '<p style="color:#999; padding:10px;">è«‹åœ¨ä¸Šæ–¹é¸æ“‡ç‰¹å®šå±€æ•¸ï¼Œå³å¯æŸ¥çœ‹æœ¬å±€è©³ç´°äº‹ä»¶ç´€éŒ„ã€‚</p>';
                return;
            }

            const events = (currentMatch.sets && currentMatch.sets[currentViewSet]) || [];
            if (events.length === 0) {
                container.innerHTML =
                    '<p style="color:#999; padding:10px;">æœ¬å±€ç›®å‰å°šç„¡ç´€éŒ„ã€‚</p>';
                return;
            }

            let html = '';
            events.forEach((ev, idx) => {
                const t = new Date(ev.time);
                const timeStr = t.toLocaleTimeString('zh-TW', { hour12: false });
                html += `
                    <div class="match-item">
                        <strong>#${idx + 1}</strong> ã€${timeStr}ã€‘<br>
                        çƒå“¡ï¼š${ev.player}<br>
                        å‹•ä½œï¼š${SKILL_LABELS[ev.skill] || ev.skill}<br>
                        çµæœï¼š${RESULT_LABELS[ev.result] || ev.result}
                    </div>`;
            });
            container.innerHTML = html;
        }

        // ===== æ•¸æ“šåˆ†æ =====
        function updateAnalysis() {
            if (!currentMatch) {
                document.getElementById('mvpDisplay').innerHTML =
                    '<div class="card">å°šæœªé–‹å§‹æ¯”è³½</div>';
                document.getElementById('rankingDisplay').innerHTML = '';
                if (window.skillChart) window.skillChart.destroy();
                if (window.rateChart) window.rateChart.destroy();
                return;
            }

            const stats = computeStats(currentViewSet);
            updateAnalysisSetLabel();
            calculateMVP(stats);
            displayRankings(stats);
            drawCharts(stats);
        }

        function calculateMVP(stats) {
            let mvp = null;
            let bestScore = -Infinity;

            Object.entries(stats).forEach(([name, s]) => {
                const totalScore =
                    s.serve.score + s.receive.score + s.attack.score +
                    s.block.score + s.set.score + s.defense.score;
                const totalError =
                    s.serve.error + s.receive.error + s.attack.error +
                    s.block.error + s.set.error + s.defense.error;

                const net = totalScore - totalError * 0.5;
                if (net > bestScore) {
                    bestScore = net;
                    mvp = name;
                }
            });

            const box = document.getElementById('mvpDisplay');
            if (!mvp || bestScore <= -Infinity) {
                box.innerHTML = '<div class="card">å°šç„¡æ•¸æ“š</div>';
                return;
            }

            const scopeText =
                currentViewSet === 'all'
                    ? 'ï¼ˆå…¨éƒ¨å±€æ•¸ï¼‰'
                    : `ï¼ˆç¬¬ ${currentViewSet} å±€ï¼‰`;

            box.innerHTML = `
                <div class="mvp-card">
                    ğŸ† MVP ${scopeText}ï¼š${mvp}
                    <div style="font-size:0.6em; margin-top:10px;">
                        ç¶œåˆè©•åˆ†ï¼š${bestScore.toFixed(1)}
                    </div>
                </div>`;
        }

        function displayRankings(stats) {
            const container = document.getElementById('rankingDisplay');
            const skills = ['serve', 'receive', 'attack', 'block', 'set', 'defense'];
            let html = '';

            skills.forEach(sk => {
                const label = SKILL_LABELS[sk];
                const ranking = Object.entries(stats)
                    .map(([name, s]) => ({
                        name,
                        score: s[sk].score
                    }))
                    .sort((a, b) => b.score - a.score)
                    .filter(r => r.score > 0)
                    .slice(0, 3);

                html += `<div style="margin-bottom:20px;">
                    <h3>${label}æ’è¡Œ</h3>`;

                if (ranking.length === 0) {
                    html += `
                        <div class="stat-row">
                            <span>ç›®å‰ç„¡ç´€éŒ„</span>
                            <span class="stat-value">-</span>
                        </div>`;
                } else {
                    ranking.forEach((r, idx) => {
                        html += `
                            <div class="stat-row">
                                <span>${idx + 1}. ${r.name}</span>
                                <span class="stat-value">${r.score}</span>
                            </div>`;
                    });
                }

                html += '</div>';
            });

            container.innerHTML = html;
        }

        function drawCharts(stats) {
            drawSkillChart(stats);
            drawRateChart(stats);
        }

        function drawSkillChart(stats) {
            const ctx = document.getElementById('skillChart');
            if (window.skillChart) window.skillChart.destroy();

            const names = Object.keys(stats);
            if (names.length === 0) return;

            const skillKeys = ['serve', 'receive', 'attack', 'block', 'set', 'defense'];
            const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'];

            const datasets = skillKeys.map((sk, idx) => ({
                label: SKILL_LABELS[sk],
                data: names.map(n => stats[n][sk].score),
                backgroundColor: colors[idx]
            }));

            window.skillChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: names,
                    datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true }
                    }
                }
            });
        }

        function drawRateChart(stats) {
            const ctx = document.getElementById('rateChart');
            if (window.rateChart) window.rateChart.destroy();

            const names = Object.keys(stats);
            if (names.length === 0) return;

            const skillKeys = ['serve', 'receive', 'attack', 'block', 'set', 'defense'];
            const data = names.map(name => {
                const s = stats[name];
                let totalRate = 0;
                let cnt = 0;
                skillKeys.forEach(sk => {
                    const total = s[sk].score + s[sk].error;
                    if (total > 0) {
                        totalRate += (s[sk].score / total) * 100;
                        cnt++;
                    }
                });
                return cnt > 0 ? totalRate / cnt : 0;
            });

            window.rateChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: names,
                    datasets: [{
                        label: 'å¹³å‡æˆåŠŸç‡ (%)',
                        data,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102,126,234,0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, max: 100 }
                    }
                }
            });
        }

        // ===== æ­·å²ç´€éŒ„åˆ—è¡¨ & å½ˆå‡ºçµ±è¨ˆ =====
        function displayMatchHistory() {
            const container = document.getElementById('matchHistory');
            if (!container) return;

            if (!matchHistory.length) {
                container.innerHTML =
                    '<p style="text-align:center; color:#999; padding:20px;">å°šç„¡æ¯”è³½ç´€éŒ„</p>';
                return;
            }

            let html = '';
            matchHistory.forEach((m, idx) => {
                const setCount = m.sets ? Object.keys(m.sets).length : 0;
                html += `
                    <div class="match-item">
                        <strong>æ¯”è³½ ${idx + 1}</strong><br>
                        æ—¥æœŸï¼š${m.date || 'â€”'}<br>
                        åœ°é»ï¼š${m.location || 'â€”'}<br>
                        å°æ‰‹ï¼š${m.opponent || 'â€”'}<br>
                        å±€æ•¸ï¼š${setCount} å±€<br>
                        <div style="margin-top:8px; display:flex; flex-wrap:wrap; gap:8px;">
                            <button class="btn-primary"
                                style="padding:6px 10px; font-size:12px;"
                                onclick="showHistoryStats(${idx})">æŸ¥çœ‹çµ±è¨ˆ</button>
                            <button class="btn-info"
                                style="padding:6px 10px; font-size:12px;"
                                onclick="loadMatchFromHistory(${idx})">è¼‰å…¥é€™å ´æ¯”è³½</button>
                            <button class="delete-btn"
                                onclick="deleteMatch(${idx})">åˆªé™¤</button>
                        </div>
                    </div>`;
            });

            container.innerHTML = html;
        }

        // ===== Supabase åŒæ­¥å‡½å¼ï¼ˆæ–°å¢ï¼‰ =====

        // æŠŠä¸€å ´æ¯”è³½å­˜åˆ° Supabase
        async function saveMatchToSupabase(match) {
            try {
                const { error } = await supabase
                    .from('volleyball_matches')
                    .upsert({
                        id: match.id,     // ä½ ç›®å‰çš„ id: Date.now()
                        data: match
                    });

                if (error) {
                    console.error('å„²å­˜åˆ° Supabase å¤±æ•—', error);
                    alert('é›²ç«¯å„²å­˜å¤±æ•—ï¼Œä½†æœ¬æ©Ÿå·²ç¶“æœ‰ç´€éŒ„ã€‚');
                } else {
                    console.log('å·²å„²å­˜åˆ° Supabase');
                }
            } catch (e) {
                console.error('å‘¼å« Supabase æ™‚ç™¼ç”ŸéŒ¯èª¤', e);
            }
        }

        // å¾ Supabase æŠ“æ‰€æœ‰æ­·å²æ¯”è³½
        async function loadMatchHistoryFromSupabase() {
            try {
                const { data, error } = await supabase
                    .from('volleyball_matches')
                    .select('*')
                    .order('created_at', { ascending: false });

                if (error) {
                    console.error('è®€å– Supabase æ­·å²å¤±æ•—', error);
                    return;
                }

                // æŠŠè³‡æ–™è¡¨ä¸­çš„ data(json) å–å›ä¾†å¡é€²ç›®å‰çš„ matchHistory
                matchHistory = (data || []).map(row => row.data);

                // ä¹ŸåŒæ­¥å› localStorageï¼Œé›¢ç·šæ™‚é‚„èƒ½çœ‹
                saveData();
                displayMatchHistory();

                console.log('å·²å¾ Supabase è¼‰å…¥æ­·å²æ¯”è³½');
            } catch (e) {
                console.error('å‘¼å« Supabase æ™‚ç™¼ç”ŸéŒ¯èª¤', e);
            }
        }

        // åˆªé™¤ä¸€å ´æ¯”è³½ï¼ˆçµ¦ deleteMatch ç”¨ï¼‰
        async function deleteMatchFromSupabase(matchId) {
            try {
                const { error } = await supabase
                    .from('volleyball_matches')
                    .delete()
                    .eq('id', matchId);

                if (error) {
                    console.error('åˆªé™¤ Supabase è³‡æ–™å¤±æ•—', error);
                }
            } catch (e) {
                console.error('å‘¼å« Supabase åˆªé™¤æ™‚éŒ¯èª¤', e);
            }
        }

        // æ¸…ç©ºæ‰€æœ‰æ¯”è³½ï¼ˆçµ¦ clearHistory ç”¨ï¼‰
        async function clearSupabaseHistory() {
            try {
                const { error } = await supabase
                    .from('volleyball_matches')
                    .delete()
                    .neq('id', 0);   // æŠŠæ‰€æœ‰ id != 0 çš„å…¨éƒ¨åˆªæ‰

                if (error) {
                    console.error('æ¸…é™¤ Supabase æ­·å²å¤±æ•—', error);
                }
            } catch (e) {
                console.error('å‘¼å« Supabase æ¸…é™¤æ™‚éŒ¯èª¤', e);
            }
        }

        // é¡¯ç¤ºæ­·å²æ¯”è³½çµ±è¨ˆå½ˆçª—
        function showHistoryStats(idx, viewSet) {
            const modal = document.getElementById('historyModal');
            const content = document.getElementById('historyModalContent');
            const match = matchHistory[idx];
            if (!modal || !content || !match) return;

            currentHistoryIdx = idx;
            currentHistoryViewSet = viewSet || currentHistoryViewSet || 'all';

            const sets = match.sets || {};
            const setKeys = Object.keys(sets).sort((a,b) => Number(a) - Number(b));

            let setOptions = `<option value="all"${currentHistoryViewSet === 'all' ? ' selected' : ''}>å…¨éƒ¨å±€æ•¸</option>`;
            setKeys.forEach(k => {
                const selected = String(currentHistoryViewSet) === String(k) ? ' selected' : '';
                setOptions += `<option value="${k}"${selected}>ç¬¬ ${k} å±€</option>`;
            });

            const stats = computeStatsForMatch(match, currentHistoryViewSet);
            const names = Object.keys(stats);

            let tableHtml = '';
            if (!names.length) {
                tableHtml = '<p style="color:#999; margin-top:10px;">å°šç„¡ç´€éŒ„</p>';
            } else {
                tableHtml += `
                    <div style="overflow-x:auto;">
                        <table style="width:100%; border-collapse:collapse; margin-top:10px;">
                            <thead>
                                <tr>
                                    <th>çƒå“¡</th>
                                    <th>ç™¼çƒ</th>
                                    <th>æ¥ç™¼</th>
                                    <th>æ”»æ“Š</th>
                                    <th>æ””ç¶²</th>
                                    <th>èˆ‰çƒ</th>
                                    <th>é˜²å®ˆ</th>
                                    <th>ç¸½å¾—åˆ†</th>
                                    <th>ç¸½å¤±èª¤</th>
                                </tr>
                            </thead>
                            <tbody>`;

                names.forEach(name => {
                    const s = stats[name];
                    const totalScore =
                        s.serve.score + s.receive.score + s.attack.score +
                        s.block.score + s.set.score + s.defense.score;
                    const totalError =
                        s.serve.error + s.receive.error + s.attack.error +
                        s.block.error + s.set.error + s.defense.error;

                    tableHtml += `
                        <tr>
                            <td>${name}</td>
                            <td>${s.serve.score}/${s.serve.error}</td>
                            <td>${s.receive.score}/${s.receive.error}</td>
                            <td>${s.attack.score}/${s.attack.error}</td>
                            <td>${s.block.score}/${s.block.error}</td>
                            <td>${s.set.score}/${s.set.error}</td>
                            <td>${s.defense.score}/${s.defense.error}</td>
                            <td style="color:#11998e; font-weight:bold;">${totalScore}</td>
                            <td style="color:#eb3349; font-weight:bold;">${totalError}</td>
                        </tr>`;
                });

                tableHtml += `
                            </tbody>
                        </table>
                    </div>`;
            }

            const scopeText =
                currentHistoryViewSet === 'all'
                    ? 'å…¨éƒ¨å±€æ•¸'
                    : `ç¬¬ ${currentHistoryViewSet} å±€`;

            content.innerHTML = `
                <h2 style="color:#667eea; margin-bottom:10px;">æ­·å²æ¯”è³½çµ±è¨ˆ</h2>
                <p><strong>æ—¥æœŸï¼š</strong>${match.date || 'â€”'}</p>
                <p><strong>åœ°é»ï¼š</strong>${match.location || 'â€”'}</p>
                <p><strong>å°æ‰‹ï¼š</strong>${match.opponent || 'â€”'}</p>
                <p style="margin-top:6px;"><strong>ç›®å‰é¡¯ç¤ºï¼š</strong>${scopeText}</p>
                <div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                    <label for="historySetSelect" style="font-weight:bold;">é¡¯ç¤ºå±€æ•¸ï¼š</label>
                    <select id="historySetSelect" onchange="onHistorySetChange()">
                        ${setOptions}
                    </select>
                </div>
                ${tableHtml}
            `;

            modal.style.display = 'flex';
        }

        function onHistorySetChange() {
            const sel = document.getElementById('historySetSelect');
            if (!sel) return;
            currentHistoryViewSet = sel.value || 'all';
            if (currentHistoryIdx !== null) {
                showHistoryStats(currentHistoryIdx, currentHistoryViewSet);
            }
        }

        function closeHistoryModal() {
            const modal = document.getElementById('historyModal');
            if (modal) modal.style.display = 'none';
        }

        function onHistoryModalBackgroundClick(e) {
            if (e.target && e.target.id === 'historyModal') {
                closeHistoryModal();
            }
        }

        function loadMatchFromHistory(idx) {
            const m = matchHistory[idx];
            if (!m) return;
            currentMatch = JSON.parse(JSON.stringify(m));
            players = Array.isArray(m.players) ? [...m.players] : [];
            currentViewSet = 'all';

            saveData();
            updateAllDisplays();
            updateSetFilterOptions();
            updateSetEventLog();
            updateAnalysis();
            alert('å·²è¼‰å…¥æ­·å²æ¯”è³½ï¼Œç¾åœ¨é¡¯ç¤ºçš„æ˜¯è©²å ´æ•¸æ“šã€‚');
        }

        function deleteMatch(idx) {
            if (!confirm('ç¢ºå®šè¦åˆªé™¤æ­¤æ¯”è³½ç´€éŒ„å—ï¼Ÿ')) return;

            const match = matchHistory[idx];
            if (match && match.id) {
                deleteMatchFromSupabase(match.id);  // ä¸ç­‰å®ƒå›ä¾†ï¼Œç›´æ¥è®“ç•«é¢å…ˆæ›´æ–°
            }

            matchHistory.splice(idx, 1);
            saveData();
            displayMatchHistory();
        }


        function clearHistory() {
    if (!confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ­·å²ç´€éŒ„å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸï¼')) return;

            // é›²ç«¯ä¹Ÿæ¸…ç©º
            clearSupabaseHistory();

            matchHistory = [];
            saveData();
            displayMatchHistory();
        }


    </script>
</body>
</html>
